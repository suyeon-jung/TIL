<p align="center"><img src="https://bimage.interpark.com/partner/goods_image/3/5/5/2/339153552g.jpg"></p>

# 목차
- [목차](#목차)
- [01장. 프로그래밍](#01장-프로그래밍)
  - [1.1 프로그래밍이란?](#11-프로그래밍이란)
  - [1.2 프로그래밍 언어](#12-프로그래밍-언어)
  - [1.3 구문과 의미](#13-구문과-의미)
- [02장. 자바스크립트란?](#02장-자바스크립트란)
  - [2.1 자바스크립트의 탄생](#21-자바스크립트의-탄생)
  - [2.2 자바스크립트의 표준화](#22-자바스크립트의-표준화)
    - [크로스 브라우징 이슈](#크로스-브라우징-이슈)
    - [표준화의 필요성](#표준화의-필요성)
  - [2.3 자바스크립트 성장의 역사](#23-자바스크립트-성장의-역사)
    - [2.3.1 Ajax](#231-ajax)
    - [2.3.2 jQuery(✏️ 추가 학습 필요)](#232-jquery️-추가-학습-필요)
    - [2.3.3 V8 자바스크립트 엔진](#233-v8-자바스크립트-엔진)
    - [2.3.4 Node.js](#234-nodejs)
    - [2.3.5 SPA 프레임워크](#235-spa-프레임워크)
  - [2.4 자바스크립트와 ECMAScript](#24-자바스크립트와-ecmascript)
    - [ECMA International](#ecma-international)
    - [ECMA-262](#ecma-262)
    - [ECMAScript(ECMAScript 사양)](#ecmascriptecmascript-사양)
    - [스크립트 언어](#스크립트-언어)
    - [JavaScript](#javascript)
    - [JavaScript 엔진(JavaScript Interpreter)](#javascript-엔진javascript-interpreter)
    - [ECMAScript 6](#ecmascript-6)
    - [바벨(Babel)](#바벨babel)
  - [2.5 자바스크립트의 특징](#25-자바스크립트의-특징)
  - [2.6 ES6 브라우저 지원 현황](#26-es6-브라우저-지원-현황)
- [03장. 자바스크립트 개발 환경과 실행 방법](#03장-자바스크립트-개발-환경과-실행-방법)
  - [3.1 자바스크립트 실행 환경](#31-자바스크립트-실행-환경)
  - [3.2 웹 브라우저](#32-웹-브라우저)
    - [3.2.1 개발자 도구](#321-개발자-도구)
    - [3.2.2 콘솔](#322-콘솔)
    - [3.2.3 브라우저에서 자바스크립트 실행](#323-브라우저에서-자바스크립트-실행)
    - [3.2.4 디버깅](#324-디버깅)
  - [3.3 Node.js](#33-nodejs)
    - [3.3.1 Node.js 와 npm 소개](#331-nodejs-와-npm-소개)
    - [3.3.2 Node.js 설치](#332-nodejs-설치)
    - [3.3.3 Node.js REPL](#333-nodejs-repl)
  - [3.4 비주얼 스튜디오 코드](#34-비주얼-스튜디오-코드)
    - [3.4.1 비주얼 스튜디오 코드 설치](#341-비주얼-스튜디오-코드-설치)
    - [3.4.2 내장 터미널](#342-내장-터미널)
    - [3.4.3 Code Runner 확장 플러그인](#343-code-runner-확장-플러그인)
    - [3.4.4 Live Server 확장 플러그인](#344-live-server-확장-플러그인)
- [04장. 변수](#04장-변수)
  - [4.1 변수란 무엇인가? 왜 필요한가?](#41-변수란-무엇인가-왜-필요한가)
  - [4.2 식별자](#42-식별자)
  - [4.3 변수 선언](#43-변수-선언)
    - [변수 선언의 단계](#변수-선언의-단계)
    - [변수 이름은 어디에 등록되는가?](#변수-이름은-어디에-등록되는가)
      - [실행 컨텍스트](#실행-컨텍스트)
  - [4.4 변수 선언의 실행 시점과 변수 호이스팅](#44-변수-선언의-실행-시점과-변수-호이스팅)
    - [변수 호이스팅(variable hoisting)](#변수-호이스팅variable-hoisting)
  - [4.5 값의 할당](#45-값의-할당)
  - [4.6 값의 재할당](#46-값의-재할당)
    - [가비지 콜렉터(garbage collector)](#가비지-콜렉터garbage-collector)
  - [4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)
    - [예약어](#예약어)
    - [예제](#예제)
    - [네이밍 컨벤션](#네이밍-컨벤션)
- [05장. 표현식과 문](#05장-표현식과-문)
  - [5.1 값](#51-값)
  - [5.2 리터럴](#52-리터럴)
  - [5.3 표현식](#53-표현식)
  - [5.4 문](#54-문)
  - [5.5 세미콜론과 세미콜론 자동 삽입 기능](#55-세미콜론과-세미콜론-자동-삽입-기능)
  - [5.6 표현식인 문과 표현식이 아닌 문](#56-표현식인-문과-표현식이-아닌-문)

# 01장. 프로그래밍
## 1.1 프로그래밍이란?

> 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션, 컴퓨터가 문제를 해결할 수 있도록 정확하고 상세하게 요구사항을 설명하는 작업
> 

문제 해결 방안을 고려할 때 컴퓨터 입장에서 문제를 바라보는 "Computational thinking"이 필요하다.

문제를 명확히 이해하고 복잡함을 단순하게 분해하고 자료를 정리하고 구분해야 하며 순서에 맞게 행위를 배열하는 능력이 필요하다.

## 1.2 프로그래밍 언어

문제를 해결하는 주체는 `컴퓨터` 이므로 사람이 이해할 수 있는 자연어가 아니라 컴퓨터가 이해할 수 있는 기계어로 명령을 전달해야 한다.

기계어로 직접 명령을 전달하는 것은 사람에게 매우 어려운 일이기 때문에 약속된 구문으로 구성된 `프로그래밍 언어` 를 사용하여 명령을 전달한다.

프로그래밍 언어로 작성된 프로그램은 기계가 이해할 수 없는 형태이기 때문에 번역기를 통해 기계어로 번역한다. 이때, 이 번역기를 `컴파일러` 혹은 `인터프리터`라고 한다.

프로그래밍 언어는 구문과 의미의 조합으로 표현된다

## 1.3 구문과 의미

프로그래밍 언어의 **문법**을 사용해 해결방안을 코드로 표현한다. **요구사항이 정확히 실현(문제가 해결)**될 때 의미가 있다고 할 수 있다.

> 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.


# 02장. 자바스크립트란?

## 2.1 자바스크립트의 탄생

1995년, 약 90%의 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어인 `자바스크립트` 를 도입하기로 결정했다.

- 자바스크립트 명명의 변천사
    
    모카(Mocha) ➡️ 라이브스크립트(LiveScript) ➡️ 자바스크립트(JavaScript)
    

자바스크립트는 현재 모든 브라우저의 표준 프로그래밍 언어로 자리 잡았다.

## 2.2 자바스크립트의 표준화

### 크로스 브라우징 이슈

- 1996년 8월 마이크로소프트에서 자바스크립트의 파생 버전인 `JScript` 를 인터넷 익스플로러3.0 에 탑재
- 마이크로소프트와 넷스케이프 커뮤니케이션즈가 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가
- 브라우저에 따라 웹페이지가 정상적으로 동작하지 않게 됨
    
    ➡️ 모든 브라우저에서 정상적으로 동작하는 웹페이지 개발하기 어려워짐
    

### 표준화의 필요성

1997년 7월, ECMA-262라고 불리는 표준화된 자바스크립트 초판 사양이 완성 되었다.

상표권 문제로 `ECMAScript` 로 명명

## 2.3 자바스크립트 성장의 역사

초창기 대부분의 로직은 주로 웹 서버에서 실행되었고, 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었다.

### 2.3.1 Ajax

> 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest라는 이름으로 등장
> 
- Ajax 등장 이전

    웹페이지는 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링

    변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받아 불필요한 데이터 통신 발생(성능 저하, 화면 깜박임 현상)

- Ajax 등장 이후
    
    웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링
    
    성능 향상 및 부드러운 화면 전환 가능
    

### 2.3.2 jQuery(✏️ 추가 학습 필요)

jQuery는 CSS 선택자(Selector) 방식을 사용해서 DOM을 더욱 쉽게 제어할 수 있다.

|구분|jQuery|순수 JavaScript|
|--|--|--
|id 선택자|`$("#foo")`|`document.getElementById("foo");`|
|tag 선택자|`$("foo")`|`document.getElementByTagName("foo");`|
|class 선택자|`$(".foo")`|`document.getElementByClassName("foo");`|
|속성 선택자|`$("[name=foo]"`)|`document.getElementsByName("foo");`|

### 2.3.3 V8 자바스크립트 엔진

더욱 빠르게 동작하는 자바스크립트 엔진의 필요성이 대두되면서 `V8 자바스크립트 엔진`이 등장했다. 이를 통해 과거 웹 서버에서 수행되던 대거 클라이언트(브라우저)로 이동했다.

### 2.3.4 Node.js

> 구글  V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
> 

브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외으 ㅣ환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다.

Node.js는 자바스크립트 엔진을 기반으로 하므로 Node.js 환경에서 동작하는 애플리케이션은 자바스크립트를 사용해 개발한다.

- 특징
    - 비동기 I/O
    - 단일 스레드 이벤트 루프 기반(요청 처리 성능이 좋음)

### 2.3.5 SPA 프레임워크

이전의 개발 방식으로는 복잡해진 개발 과정을 수행하기 어려워졌고, 이러한 필요에 따라 많은 패턴과 라이브러리가 출현했다.

- SPA 프레임워크/라이브러리
    - Angular
    - React
    - Vue.js
    - Svelte

## 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다.

자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, DOM, BOM, Canvas, XMLHttpReqeust, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등을 아우르는 개념이다.

### ECMA International

> 정보 통신에 대한 표준을 제정하는 비영리 표준화 기구
> 

### ECMA-262

ECMA International에 의해 제정된 하나의 기술 규격의 이름으로 범용 목적의 스크립트 언어에 대한 명세를 담고 있다.

스크립트 언어에 대한 표준을 정의한 규칙

### ECMAScript(ECMAScript 사양)

ECMA International에 의해 제정된 ECMA-262 기술 규격에 의해 정의된 범용 스크립트 언어이다.

스크립트 언어가 준수해야 하는 **규칙**, 세부 사항 및 지침을 제공한다.

### 스크립트 언어

독립된 시스템에서 작동하도록 특별히 설계된 프로그래밍 언어

### JavaScript

ECMAScript 사양을 준수하는 범용 스크립트 언어이다.

### JavaScript 엔진(JavaScript Interpreter)

JavaScript 코드를 이해하고 실행하는 프로그램 또는 인터프리터

- 종류
    - Google Chrome의 V8
    - Mozilla Firefox의 SpiderMonkey
    - Microsoft Edge의 Chakra
    - Safari의 JavaScriptCore

### ECMAScript 6

= `ES6`, `ES2015`, `ECMAScript 2015`

ECMA-262 표준의 6판이며 ECMAScript 사양의 주요 변경 사항 및 개선 사항을 명세한다.

### 바벨(Babel)

ES6에 새로 도입된 새로운 기술을 사용할 수 있지만 브라우저별 호환성 문제 때문에 문제가 발생한다.

예시) 마이크로소프트의 Internet Explorer는 ES6 사양을 준수하지 않음

바벨은 ES6 사양으로 작성된 코드를 함수적으로 동일한 ES5 코드로 바꿔준다.

## 2.5 자바스크립트의 특징

HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어다.

- 인터프리터 언어 : 별도의 컴파일 작업을 수행하지 않음
- 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리속도가 느린 인터프리터의 단점을 해결
- 멀티 패러다임 프로그래밍 언어 : 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍 지원

## 2.6 ES6 브라우저 지원 현황

브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나 인터넷 익스플로러나 구형 브라우저를 고려해야 하는 상황이라면 바벨고 ㅏ같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 ES5 이하의 사양으로 다운그레이드할 필요가 있다.

# 03장. 자바스크립트 개발 환경과 실행 방법
## 3.1 자바스크립트 실행 환경

모든 `브라우저`와 `Node.js` 는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다.

- 브라우저
    
    HTML, CSS, 자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링
    
    - DOM API 제공
    - 파일 시스템 제공 안함
        
        ➡️ **클라이언트 사이드 Web API 지원**
        
- Node.js
    
    브라우저 외부에서 자바스크립트 실행 환경을 제공
    
    - DOM API 제공 안함, DOM 라이브러리 사용
    - 파일 시스템 제공
        
        ➡️ **ECMAScript와 Node.js의 고유 API 지원**
        

두 실행 환경이 목적이 다르기 때문에 브라우저와 Node.js에서 ECMAScript 이외에 추가로 제공하는 기능은 호환되지 않는다.

## 3.2 웹 브라우저

구글 크롬 브라우저는 ECMAScript 사양을 준수하면서 시장 점유율이 가장 높다.

### 3.2.1 개발자 도구

- 기능
    - Elements
        
        로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해볼 수 있다. (저장은 안됨)
        
    - Console
        
        로딩된 웹페이지으 ㅣ에러를 확인하거나 자바스크립트 소스코드에서 작성한 `console.log` 메서드의 실행 결과를 확인할 수 있다.
        
    - Sources
        
        로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있다.
        
    - Network
        
        로딩된 웹페이지에 관련된 네트워크 요청정보와 성능을 확인할 수 있다.
        
    - Application
        
        웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.
        

### 3.2.2 콘솔

자바스크립트 코드에서 에러가 발생해 애플리케이션이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳이다.

콘솔은 자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있다. `REPL(Read Eval Print Loop: 입력 수행 출력 반복)` 환경으로 사용할 수도 있다.

### 3.2.3 브라우저에서 자바스크립트 실행

브라우저는 HTML 파일을 로드하면 `script` 태그에 포함된 자바스크립트 코드를 실행한다.

### 3.2.4 디버깅

개발자도구에서 소스 탭에서 디버깅을 할 수 있다.

## 3.3 Node.js

### 3.3.1 Node.js 와 npm 소개

Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다.

npm(node package manager)은 자바스크립트 매니저로 Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.

### 3.3.2 Node.js 설치

- Node.js 웹사이트 : [http://nodejs.org](http://nodejs.org/)
- LTS(Long Term Support) : 장기적으로 안정된 지원이 보장
- Current : 최신 기능을 제공하지만 업데이트가 발생하는 버전
- 설치 확인
    
    ```
    $ node -v
    $ npm -v
    ```
    

### 3.3.3 Node.js REPL

Node.js가 제공하는 REPL을 사용하면 간단한 자바스크립트 코드를 실행해 결과를 확인해볼 수 있다.

```
$ node // 프롬프트 활성화
$ node index.js // 자바스크립트 파일 실행(파일 확장자 생략 가능)
```

## 3.4 비주얼 스튜디오 코드

### 3.4.1 비주얼 스튜디오 코드 설치

코드 에디터를 사용하면 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다.

### 3.4.2 내장 터미널

VS Code에는 터미널이 내장되어 있다. (단축키 Ctrl + `)

### 3.4.3 Code Runner 확장 플러그인

Code Runner 확장 플러그인을 사용하면 VS Code의 내장 터미널에서 단축키를 사용해 자바스크립트를 비롯해 다양한 프로그래밍 언어로 구현된 소스코드를 간단히 실행할 수 있다.

control + option + N 단축키를 사용해 현재 표시 중인 자바스크립트 파일을 실행할 수 있다.

Code Runner 확장 플러그인은 Node.js 환경을 사용해 자바스크립트를 실행한다. 따라서 클라이언트 사이드 Web API 가 포함된 소스코드는 Code Runner 확장 플러그인이 아닌 브라우저 환경에서 실행해야 한다.

### 3.4.4 Live Server 확장 플러그인

클라이언트 사이드 Web API가 포함된 자바스크립트 코드를 실행하려면 개발자 도구의 콘솔에서 실행하거나 자바스크립트 코드를 HTML에 삽입한 다음 HTML 파일을 브라우저에서 열어야 한다.

이때, Live Server 확장 플러그인을 사용하면 소스코드를 수정할 때마다 수정 사항을 브라우저에 자동으로 반영해주기 때무에 매우 편리하다.

`Go Live` 버튼을 클릭하면 가상 서버가 기동되어 브라우저에 HTML 파일이 자동 로딩된다. 이후 소스코드를 수정하면 수정 사항이 가상 서버에 자동으로 반영된다.

# 04장. 변수
## 4.1 변수란 무엇인가? 왜 필요한가?

> **변수란?** 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.
> 
- **변수에 여러 개의 값을 저장하는 방법**
    
    ```jsx
    var userId = 1;
    var userName = 'Lee';
    
    var user = {id: 1, name: 'Lee'};
    
    var users = [
    	{ id: 1, name: 'Lee' },
    	{ id: 2, name: 'Jung' }
    ]
    ```
    
    1. 여러개의 변수
    2. 배열
    3. 객체
- **변수 이름**  - 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- **변수 값 -** 변수에 저장된 값
- **할당(대입, 저장)** - 변수의 값을 저장
- **참조 -** 변수에 저장된 값을 읽어 들이는 것

## 4.2 식별자

> **식별자란(identifier)?** 어떤 값을 구별해서 식별할 수 있는 고유한 이름
> 
- 식별자는 값이 아니라 메모리 주소를 기억한다.

## 4.3 변수 선언

- 변수를 생성하는 것(값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비)
- 변수를 사용하려면 반드시 선언이 필요하다.
    - 선언하지 않은 식별자에 접근하는 경우 `ReferenceError` 가 발생한다.
- 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

```jsx
var score;
```

변수를 선언한 이후 변수에 값을 할당하지 않으면 확보된 메모리 공간 안에는 `undefined` 라는 값이 암묵적으로 할당되어 초기화된다. 

### 변수 선언의 단계

1. **선언 단계**
2. **초기화 단계** 
    - 변수가 선언된 이후 최초로 값을 할당하는 것
    - `var` 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 `undefined` 값을 가진다.

### 변수 이름은 어디에 등록되는가?

- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.

#### 실행 컨텍스트

> 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 식별자와 스코프를 관리한다.
> 

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // 1(실행 순서)

var score; // 2(실행 순서)
```

위 코드는 참조에러가 발생할 것 같지만 실제로 `undefined` 가 출력된다.

→ **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.** 

### 변수 호이스팅(variable hoisting)

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
- 모든 선언문은 런타임 이전 단계에서 먼저 실행된다.

## 4.5 값의 할당

- 할당 연산자 `=` 을 사용하여 변수에 값을 할당한다.

```javascript
var score;
score = 80;

var score = 80;
```

- 변수 선언 → 런타임 이전에 먼저 실행
- 값의 할당 → 소스코드가 순차적으로 실행되는 시점인 런타임에 실행

```jsx
console.log(score); // undefined

var score = 80;

console.log(score); // 80
```

```jsx
console.log(score); // undefined

score = 80;

var score;

console.log(score); // 80
```

## 4.6 값의 재할당

```jsx
var score = 80;

score = 70;
```

- `var` 키워드로 선언한 변수는 값을 재할당할 수 있다.
- 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.
- 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다.

### 가비지 콜렉터(garbage collector)

> 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. (어떤 식별자도 참조하지 않는 메모리 공간)
> 

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

### 예약어

> 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 
Ex. `await`, `break`, `case` 등
> 

### 예제

- 쉼표(,)로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있다.

```jsx
var person, $elem, _name, first_name, val1;
```

- ES5부터 식별자를 만들때 유니코드 문자를 허용한다.

```jsx
var 이름;
```

- 자바스크립트는 대소문자를 구별하므로 다음은 각각 별개의 변수다.

```jsx
var firstname;
var firstName;
var FIRSTNAME;
```

- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

### 네이밍 컨벤션

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리안 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

- 자바스크립트에서는 일반적으로 변수나 함수에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.

# 05장. 표현식과 문

## 5.1 값

> 값은 **식(표현식-expression)이 평가(evaluate)되어 생성된 결과**를 말한다.
> 
- 변수에 할당되는 것은 값이다.

```jsx
var sum = 10 + 20;
```

## 5.2 리터럴

> 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(`’’`, `""`, `.`, `[]`, `{}`, `//` 등)를 사용해 값을 생성하는 표기법을 말한다.
> 

```jsx
// 숫자 리터럴 3
3
```

- 자바스크립트 엔진은 코드가 실행되는 시점인 **런타임**에 리터럴을 평가해 값을 생성한다.

## 5.3 표현식

> 표현식(expression)은 **값으로 평가될 수 있는 문**(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
> 

```jsx
// 리터럴과 연산자로 이루어져도 평가되어 숫자 값 100을 생성하므로 표현식
var score = 50 + 50;
// 변수 식별자를 참조시 변수 값으로 평가
score;
```

- **표현식 종류**
    - 리터럴 표현식
    - 식별자 표현식(선언이 이미 존재한다고 가정)
    - 연산자 표현식
    - 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
- 표현식과 표현식이 평가된 값은 동치 관계이므로 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.

## 5.4 문

> 문(statement)는 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
> 
- 문의 집합이 프로그램이다.
- 문은 토큰(token)으로 구성된다.
    - 토큰 - 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
        - 키워드
        - 식별자
        - 연산자
        - 리터럴
        - 세미콜론
        - 마침표
        - 특수기호
- **문의 구분**
    - 선언문 - `var x;`
    - 할당문 - `x = 5;`
    - 함수 선언문 - `function foo () {}`
    - 조건문 - `if (x > 1) { return; }`
    - 반복문 - `for (var i = 0; i < 2; i++) { return; }`
    

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(`;`)
    - 문의 종료를 나타낸다.
    - 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
    - 코드 블록(`{ ... }`) 뒤에는 세미콜론을 붙이지 않는다. → 언제나 문의 종료를 의미하는 자체 종결성을 가지기 때문이다.
    - 문의 끝에 붙이는 세미콜론은 옵션이다. → 세미콜론 자동 삽입 기능(ASI)이 암묵적으로 수행되기 떄문이다.

## 5.6 표현식인 문과 표현식이 아닌 문

- **표현식인 문과 표현식이 아닌 문 구분하는 방법**
    - **표현식인 문** - 값으로 평가될 수 있는 문
    - **표현식이 아닌 문** - 값으로 평가될 수 없는 문
    
    → **변수에 할당**해봐서 구분하는 것이 가장 간단한 방법이다. 
    

```jsx
// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo);
```

- **완료 값(completion value)**
    - 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined` 를 출력한다. 이를 완료 값이라고 한다.
    - 표현식의 평가 결과가 아니므로 변수에 할당할 수 없고 참조할 수도 없다.