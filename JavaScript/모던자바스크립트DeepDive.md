<p align="center"><img src="https://bimage.interpark.com/partner/goods_image/3/5/5/2/339153552g.jpg"></p>

# 목차
- [목차](#목차)
- [01장. 프로그래밍](#01장-프로그래밍)
  - [1.1 프로그래밍이란?](#11-프로그래밍이란)
  - [1.2 프로그래밍 언어](#12-프로그래밍-언어)
  - [1.3 구문과 의미](#13-구문과-의미)
- [02장. 자바스크립트란?](#02장-자바스크립트란)
  - [2.1 자바스크립트의 탄생](#21-자바스크립트의-탄생)
  - [2.2 자바스크립트의 표준화](#22-자바스크립트의-표준화)
    - [크로스 브라우징 이슈](#크로스-브라우징-이슈)
    - [표준화의 필요성](#표준화의-필요성)
  - [2.3 자바스크립트 성장의 역사](#23-자바스크립트-성장의-역사)
    - [2.3.1 Ajax](#231-ajax)
    - [2.3.2 jQuery(✏️ 추가 학습 필요)](#232-jquery️-추가-학습-필요)
    - [2.3.3 V8 자바스크립트 엔진](#233-v8-자바스크립트-엔진)
    - [2.3.4 Node.js](#234-nodejs)
    - [2.3.5 SPA 프레임워크](#235-spa-프레임워크)
  - [2.4 자바스크립트와 ECMAScript](#24-자바스크립트와-ecmascript)
    - [ECMA International](#ecma-international)
    - [ECMA-262](#ecma-262)
    - [ECMAScript(ECMAScript 사양)](#ecmascriptecmascript-사양)
    - [스크립트 언어](#스크립트-언어)
    - [JavaScript](#javascript)
    - [JavaScript 엔진(JavaScript Interpreter)](#javascript-엔진javascript-interpreter)
    - [ECMAScript 6](#ecmascript-6)
    - [바벨(Babel)](#바벨babel)
  - [2.5 자바스크립트의 특징](#25-자바스크립트의-특징)
  - [2.6 ES6 브라우저 지원 현황](#26-es6-브라우저-지원-현황)
- [03장. 자바스크립트 개발 환경과 실행 방법](#03장-자바스크립트-개발-환경과-실행-방법)
  - [3.1 자바스크립트 실행 환경](#31-자바스크립트-실행-환경)
  - [3.2 웹 브라우저](#32-웹-브라우저)
    - [3.2.1 개발자 도구](#321-개발자-도구)
    - [3.2.2 콘솔](#322-콘솔)
    - [3.2.3 브라우저에서 자바스크립트 실행](#323-브라우저에서-자바스크립트-실행)
    - [3.2.4 디버깅](#324-디버깅)
  - [3.3 Node.js](#33-nodejs)
    - [3.3.1 Node.js 와 npm 소개](#331-nodejs-와-npm-소개)
    - [3.3.2 Node.js 설치](#332-nodejs-설치)
    - [3.3.3 Node.js REPL](#333-nodejs-repl)
  - [3.4 비주얼 스튜디오 코드](#34-비주얼-스튜디오-코드)
    - [3.4.1 비주얼 스튜디오 코드 설치](#341-비주얼-스튜디오-코드-설치)
    - [3.4.2 내장 터미널](#342-내장-터미널)
    - [3.4.3 Code Runner 확장 플러그인](#343-code-runner-확장-플러그인)
    - [3.4.4 Live Server 확장 플러그인](#344-live-server-확장-플러그인)
- [04장. 변수](#04장-변수)
  - [4.1 변수란 무엇인가? 왜 필요한가?](#41-변수란-무엇인가-왜-필요한가)
  - [4.2 식별자](#42-식별자)
  - [4.3 변수 선언](#43-변수-선언)
    - [변수 선언의 단계](#변수-선언의-단계)
    - [변수 이름은 어디에 등록되는가?](#변수-이름은-어디에-등록되는가)
      - [실행 컨텍스트](#실행-컨텍스트)
  - [4.4 변수 선언의 실행 시점과 변수 호이스팅](#44-변수-선언의-실행-시점과-변수-호이스팅)
    - [변수 호이스팅(variable hoisting)](#변수-호이스팅variable-hoisting)
  - [4.5 값의 할당](#45-값의-할당)
  - [4.6 값의 재할당](#46-값의-재할당)
    - [가비지 콜렉터(garbage collector)](#가비지-콜렉터garbage-collector)
  - [4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)
    - [예약어](#예약어)
    - [예제](#예제)
    - [네이밍 컨벤션](#네이밍-컨벤션)
- [05장. 표현식과 문](#05장-표현식과-문)
  - [5.1 값](#51-값)
  - [5.2 리터럴](#52-리터럴)
  - [5.3 표현식](#53-표현식)
  - [5.4 문](#54-문)
  - [5.5 세미콜론과 세미콜론 자동 삽입 기능](#55-세미콜론과-세미콜론-자동-삽입-기능)
  - [5.6 표현식인 문과 표현식이 아닌 문](#56-표현식인-문과-표현식이-아닌-문)
- [06장. 데이터 타입](#06장-데이터-타입)
  - [6.1 숫자 타입](#61-숫자-타입)
  - [6.2 문자열 타입](#62-문자열-타입)
  - [6.3 템플릿 리터럴](#63-템플릿-리터럴)
    - [6.3.1 멀티라인 문자열](#631-멀티라인-문자열)
    - [6.3.2 표현식 삽입](#632-표현식-삽입)
  - [6.4 불리언 타입](#64-불리언-타입)
  - [6.5 `undefined` 타입](#65-undefined-타입)
  - [6.6 `null` 타입](#66-null-타입)
  - [6.7 심벌 타입](#67-심벌-타입)
  - [6.8 객체 타입](#68-객체-타입)
  - [6.9 데이터 타입의 필요성](#69-데이터-타입의-필요성)
    - [6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조](#691-데이터-타입에-의한-메모리-공간의-확보와-참조)
    - [6.9.2 데이터 타입에 의한 값의 해석](#692-데이터-타입에-의한-값의-해석)
  - [6.10 동적 타이핑](#610-동적-타이핑)
    - [6.10.1 동적 타입 언어와 정적 타입 언어](#6101-동적-타입-언어와-정적-타입-언어)
- [07장. 연산자](#07장-연산자)
  - [7.1 산술 연산자](#71-산술-연산자)
    - [7.1.1 이항 산술 연산자](#711-이항-산술-연산자)
    - [7.1.2 단항 산술 연산자](#712-단항-산술-연산자)
    - [7.1.3 문자열 연결 연산자](#713-문자열-연결-연산자)
  - [7.2 할당 연산자](#72-할당-연산자)
  - [7.3 비교 연산자](#73-비교-연산자)
    - [7.3.1 동등/일치 비교 연산자](#731-동등일치-비교-연산자)
    - [7.3.2 대소 관계 비교 연산자](#732-대소-관계-비교-연산자)
  - [7.4 삼항 조건 연산자](#74-삼항-조건-연산자)
  - [7.5 논리 연산자](#75-논리-연산자)
  - [7.6 쉼표 연산자](#76-쉼표-연산자)
  - [7.7 그룹 연산자](#77-그룹-연산자)
  - [7.8 `typeof` 연산자](#78-typeof-연산자)
  - [7.9 지수 연산자](#79-지수-연산자)
  - [7.10 그 외의 연산자](#710-그-외의-연산자)
  - [7.11 연산자의 부수 효과](#711-연산자의-부수-효과)
  - [7.12 연산자 우선순위](#712-연산자-우선순위)
  - [7.13 연산자 결합 순서](#713-연산자-결합-순서)
- [08장. 제어문](#08장-제어문)
  - [8.1 블록문](#81-블록문)
  - [8.2 조건문](#82-조건문)
    - [8.2.1 `if...else` 문](#821-ifelse-문)
    - [8.2.2 `switch` 문](#822-switch-문)
  - [8.3 반복문](#83-반복문)
    - [8.3.1 `for` 문](#831-for-문)
    - [8.3.2 `while` 문](#832-while-문)
    - [8.3.3 `do...while` 문](#833-dowhile-문)
  - [8.4 `break` 문](#84-break-문)
  - [8.5 `continue` 문](#85-continue-문)
- [09장. 타입 변환과 단축 평가](#09장-타입-변환과-단축-평가)
  - [9.1 타입 변환이란?](#91-타입-변환이란)
  - [9.2 암묵적 타입 변환](#92-암묵적-타입-변환)
    - [9.2.1 문자열 타입으로 변환](#921-문자열-타입으로-변환)
    - [9.2.2 숫자 타입으로 변환](#922-숫자-타입으로-변환)
    - [9.2.3 불리언 타입으로 변환](#923-불리언-타입으로-변환)
  - [9.3 명시적 타입 변환](#93-명시적-타입-변환)
    - [9.3.1 문자열 타입으로 변환](#931-문자열-타입으로-변환)
    - [9.3.2 숫자 타입으로 변환](#932-숫자-타입으로-변환)
    - [9.3.3 불리언 타입으로 변환](#933-불리언-타입으로-변환)
  - [9.4 단축 평가](#94-단축-평가)
    - [9.4.1 논리 연산자를 사용한 단축 평가](#941-논리-연산자를-사용한-단축-평가)
    - [9.4.3 null 병합 연산자](#943-null-병합-연산자)
- [10. 객체 리터럴](#10-객체-리터럴)
  - [10.1 객체란](#101-객체란)
    - [객체의 구성](#객체의-구성)
  - [10.2 객체 리터럴에 의한 객체 생성](#102-객체-리터럴에-의한-객체-생성)
  - [10.3 프로퍼티](#103-프로퍼티)
  - [10.4 메서드](#104-메서드)
  - [10.5 프로퍼티 접근](#105-프로퍼티-접근)
  - [10.6 프로퍼티 값 갱신](#106-프로퍼티-값-갱신)
  - [10.8 프로퍼티 삭제](#108-프로퍼티-삭제)
  - [10.9 ES6에서 추가된 객체 리터럴의 확장 기능](#109-es6에서-추가된-객체-리터럴의-확장-기능)
    - [10.9.1 프로퍼티 축약 표현](#1091-프로퍼티-축약-표현)
    - [10.9.2 계산된 프로퍼티 이름](#1092-계산된-프로퍼티-이름)
    - [10.9.3 메서드 축약 표현](#1093-메서드-축약-표현)
- [11장. 원시 값과 객체의 비교](#11장-원시-값과-객체의-비교)
  - [데이터 타입](#데이터-타입)
    - [원시 타입(primitive type)](#원시-타입primitive-type)
    - [객체 타입(object/reference type)](#객체-타입objectreference-type)
  - [11.1 원시 값](#111-원시-값)
    - [11.1.1 변경 불가능한 값](#1111-변경-불가능한-값)
    - [11.1.2 문자열과 불변성](#1112-문자열과-불변성)
    - [11.1.3 값에 의한 전달](#1113-값에-의한-전달)
  - [11.2 객체](#112-객체)
    - [11.2.1 변경 가능한 값](#1121-변경-가능한-값)
    - [11.2.2 참조에 의한 전달](#1122-참조에-의한-전달)
- [12장. 함수](#12장-함수)
  - [12.1 함수란?](#121-함수란)
  - [12.2 함수를 사용하는 이유](#122-함수를-사용하는-이유)
  - [12.3 함수 리터럴](#123-함수-리터럴)
  - [12.4 함수 정의](#124-함수-정의)
    - [12.4.3 함수 생성 시점과 함수 호이스팅](#1243-함수-생성-시점과-함수-호이스팅)
  - [12.5 함수 호출](#125-함수-호출)
    - [12.5.1 매개변수와 인수](#1251-매개변수와-인수)
    - [12.5.2 인수 확인](#1252-인수-확인)
    - [12.5.3 매개변수의 최대 개수](#1253-매개변수의-최대-개수)
    - [12.5.4 반환문](#1254-반환문)
  - [12.6 참조에 의한 전달과 외부 상태의 변경](#126-참조에-의한-전달과-외부-상태의-변경)
  - [12.7 다양한 함수의 형태](#127-다양한-함수의-형태)
    - [12.7.1 즉시 실행 함수](#1271-즉시-실행-함수)
    - [12.7.2 재귀 함수](#1272-재귀-함수)
    - [12.7.3 중첩 함수](#1273-중첩-함수)
    - [12.7.4 콜백 함수](#1274-콜백-함수)
    - [12.7.5 순수 함수와 비순수 함수](#1275-순수-함수와-비순수-함수)
- [13장. 스코프](#13장-스코프)
  - [13.1 스코프란?](#131-스코프란)
  - [13.2 스코프의 종류](#132-스코프의-종류)
    - [13.2.2 지역과 지역 스코프](#1322-지역과-지역-스코프)
  - [13.3 스코프 체인](#133-스코프-체인)
  - [13.4 함수 레벨 스코프](#134-함수-레벨-스코프)
  - [13.5 렉시컬 스코프](#135-렉시컬-스코프)
- [14장. 전역 변수의 문제점](#14장-전역-변수의-문제점)
  - [14.1 변수의 생명 주기](#141-변수의-생명-주기)
    - [14.1.1 지역 변수의 생명 주기](#1411-지역-변수의-생명-주기)
    - [14.1.2 전역 변수의 생명 주기](#1412-전역-변수의-생명-주기)
  - [14.2 전역 변수의 문제점](#142-전역-변수의-문제점)
  - [14.3 전역 변수의 사용을 억제하는 방법](#143-전역-변수의-사용을-억제하는-방법)
    - [14.3.1 즉시 실행 함수](#1431-즉시-실행-함수)
    - [14.3.2 네임스페이스 객체](#1432-네임스페이스-객체)
    - [14.3.3 모듈 패턴](#1433-모듈-패턴)
    - [14.3.4 ES6 모듈](#1434-es6-모듈)

# 01장. 프로그래밍
## 1.1 프로그래밍이란?

> 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션, 컴퓨터가 문제를 해결할 수 있도록 정확하고 상세하게 요구사항을 설명하는 작업
> 

문제 해결 방안을 고려할 때 컴퓨터 입장에서 문제를 바라보는 "Computational thinking"이 필요하다.

문제를 명확히 이해하고 복잡함을 단순하게 분해하고 자료를 정리하고 구분해야 하며 순서에 맞게 행위를 배열하는 능력이 필요하다.

## 1.2 프로그래밍 언어

문제를 해결하는 주체는 `컴퓨터` 이므로 사람이 이해할 수 있는 자연어가 아니라 컴퓨터가 이해할 수 있는 기계어로 명령을 전달해야 한다.

기계어로 직접 명령을 전달하는 것은 사람에게 매우 어려운 일이기 때문에 약속된 구문으로 구성된 `프로그래밍 언어` 를 사용하여 명령을 전달한다.

프로그래밍 언어로 작성된 프로그램은 기계가 이해할 수 없는 형태이기 때문에 번역기를 통해 기계어로 번역한다. 이때, 이 번역기를 `컴파일러` 혹은 `인터프리터`라고 한다.

프로그래밍 언어는 구문과 의미의 조합으로 표현된다

## 1.3 구문과 의미

프로그래밍 언어의 **문법**을 사용해 해결방안을 코드로 표현한다. **요구사항이 정확히 실현(문제가 해결)**될 때 의미가 있다고 할 수 있다.

> 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.


# 02장. 자바스크립트란?

## 2.1 자바스크립트의 탄생

1995년, 약 90%의 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어인 `자바스크립트` 를 도입하기로 결정했다.

- 자바스크립트 명명의 변천사
    
    모카(Mocha) ➡️ 라이브스크립트(LiveScript) ➡️ 자바스크립트(JavaScript)
    

자바스크립트는 현재 모든 브라우저의 표준 프로그래밍 언어로 자리 잡았다.

## 2.2 자바스크립트의 표준화

### 크로스 브라우징 이슈

- 1996년 8월 마이크로소프트에서 자바스크립트의 파생 버전인 `JScript` 를 인터넷 익스플로러3.0 에 탑재
- 마이크로소프트와 넷스케이프 커뮤니케이션즈가 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가
- 브라우저에 따라 웹페이지가 정상적으로 동작하지 않게 됨
    
    ➡️ 모든 브라우저에서 정상적으로 동작하는 웹페이지 개발하기 어려워짐
    

### 표준화의 필요성

1997년 7월, ECMA-262라고 불리는 표준화된 자바스크립트 초판 사양이 완성 되었다.

상표권 문제로 `ECMAScript` 로 명명

## 2.3 자바스크립트 성장의 역사

초창기 대부분의 로직은 주로 웹 서버에서 실행되었고, 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었다.

### 2.3.1 Ajax

> 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest라는 이름으로 등장
> 
- Ajax 등장 이전

    웹페이지는 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링

    변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받아 불필요한 데이터 통신 발생(성능 저하, 화면 깜박임 현상)

- Ajax 등장 이후
    
    웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링
    
    성능 향상 및 부드러운 화면 전환 가능
    

### 2.3.2 jQuery(✏️ 추가 학습 필요)

jQuery는 CSS 선택자(Selector) 방식을 사용해서 DOM을 더욱 쉽게 제어할 수 있다.

|구분|jQuery|순수 JavaScript|
|--|--|--
|id 선택자|`$("#foo")`|`document.getElementById("foo");`|
|tag 선택자|`$("foo")`|`document.getElementByTagName("foo");`|
|class 선택자|`$(".foo")`|`document.getElementByClassName("foo");`|
|속성 선택자|`$("[name=foo]"`)|`document.getElementsByName("foo");`|

### 2.3.3 V8 자바스크립트 엔진

더욱 빠르게 동작하는 자바스크립트 엔진의 필요성이 대두되면서 `V8 자바스크립트 엔진`이 등장했다. 이를 통해 과거 웹 서버에서 수행되던 대거 클라이언트(브라우저)로 이동했다.

### 2.3.4 Node.js

> 구글  V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
> 

브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외으 ㅣ환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다.

Node.js는 자바스크립트 엔진을 기반으로 하므로 Node.js 환경에서 동작하는 애플리케이션은 자바스크립트를 사용해 개발한다.

- 특징
    - 비동기 I/O
    - 단일 스레드 이벤트 루프 기반(요청 처리 성능이 좋음)

### 2.3.5 SPA 프레임워크

이전의 개발 방식으로는 복잡해진 개발 과정을 수행하기 어려워졌고, 이러한 필요에 따라 많은 패턴과 라이브러리가 출현했다.

- SPA 프레임워크/라이브러리
    - Angular
    - React
    - Vue.js
    - Svelte

## 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다.

자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, DOM, BOM, Canvas, XMLHttpReqeust, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등을 아우르는 개념이다.

### ECMA International

> 정보 통신에 대한 표준을 제정하는 비영리 표준화 기구
> 

### ECMA-262

ECMA International에 의해 제정된 하나의 기술 규격의 이름으로 범용 목적의 스크립트 언어에 대한 명세를 담고 있다.

스크립트 언어에 대한 표준을 정의한 규칙

### ECMAScript(ECMAScript 사양)

ECMA International에 의해 제정된 ECMA-262 기술 규격에 의해 정의된 범용 스크립트 언어이다.

스크립트 언어가 준수해야 하는 **규칙**, 세부 사항 및 지침을 제공한다.

### 스크립트 언어

독립된 시스템에서 작동하도록 특별히 설계된 프로그래밍 언어

### JavaScript

ECMAScript 사양을 준수하는 범용 스크립트 언어이다.

### JavaScript 엔진(JavaScript Interpreter)

JavaScript 코드를 이해하고 실행하는 프로그램 또는 인터프리터

- 종류
    - Google Chrome의 V8
    - Mozilla Firefox의 SpiderMonkey
    - Microsoft Edge의 Chakra
    - Safari의 JavaScriptCore

### ECMAScript 6

= `ES6`, `ES2015`, `ECMAScript 2015`

ECMA-262 표준의 6판이며 ECMAScript 사양의 주요 변경 사항 및 개선 사항을 명세한다.

### 바벨(Babel)

ES6에 새로 도입된 새로운 기술을 사용할 수 있지만 브라우저별 호환성 문제 때문에 문제가 발생한다.

예시) 마이크로소프트의 Internet Explorer는 ES6 사양을 준수하지 않음

바벨은 ES6 사양으로 작성된 코드를 함수적으로 동일한 ES5 코드로 바꿔준다.

## 2.5 자바스크립트의 특징

HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어다.

- 인터프리터 언어 : 별도의 컴파일 작업을 수행하지 않음
- 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리속도가 느린 인터프리터의 단점을 해결
- 멀티 패러다임 프로그래밍 언어 : 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍 지원

## 2.6 ES6 브라우저 지원 현황

브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나 인터넷 익스플로러나 구형 브라우저를 고려해야 하는 상황이라면 바벨고 ㅏ같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 ES5 이하의 사양으로 다운그레이드할 필요가 있다.

# 03장. 자바스크립트 개발 환경과 실행 방법
## 3.1 자바스크립트 실행 환경

모든 `브라우저`와 `Node.js` 는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다.

- 브라우저
    
    HTML, CSS, 자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링
    
    - DOM API 제공
    - 파일 시스템 제공 안함
        
        ➡️ **클라이언트 사이드 Web API 지원**
        
- Node.js
    
    브라우저 외부에서 자바스크립트 실행 환경을 제공
    
    - DOM API 제공 안함, DOM 라이브러리 사용
    - 파일 시스템 제공
        
        ➡️ **ECMAScript와 Node.js의 고유 API 지원**
        

두 실행 환경이 목적이 다르기 때문에 브라우저와 Node.js에서 ECMAScript 이외에 추가로 제공하는 기능은 호환되지 않는다.

## 3.2 웹 브라우저

구글 크롬 브라우저는 ECMAScript 사양을 준수하면서 시장 점유율이 가장 높다.

### 3.2.1 개발자 도구

- 기능
    - Elements
        
        로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해볼 수 있다. (저장은 안됨)
        
    - Console
        
        로딩된 웹페이지으 ㅣ에러를 확인하거나 자바스크립트 소스코드에서 작성한 `console.log` 메서드의 실행 결과를 확인할 수 있다.
        
    - Sources
        
        로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있다.
        
    - Network
        
        로딩된 웹페이지에 관련된 네트워크 요청정보와 성능을 확인할 수 있다.
        
    - Application
        
        웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.
        

### 3.2.2 콘솔

자바스크립트 코드에서 에러가 발생해 애플리케이션이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳이다.

콘솔은 자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있다. `REPL(Read Eval Print Loop: 입력 수행 출력 반복)` 환경으로 사용할 수도 있다.

### 3.2.3 브라우저에서 자바스크립트 실행

브라우저는 HTML 파일을 로드하면 `script` 태그에 포함된 자바스크립트 코드를 실행한다.

### 3.2.4 디버깅

개발자도구에서 소스 탭에서 디버깅을 할 수 있다.

## 3.3 Node.js

### 3.3.1 Node.js 와 npm 소개

Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다.

npm(node package manager)은 자바스크립트 매니저로 Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.

### 3.3.2 Node.js 설치

- Node.js 웹사이트 : [http://nodejs.org](http://nodejs.org/)
- LTS(Long Term Support) : 장기적으로 안정된 지원이 보장
- Current : 최신 기능을 제공하지만 업데이트가 발생하는 버전
- 설치 확인
    
    ```
    $ node -v
    $ npm -v
    ```
    

### 3.3.3 Node.js REPL

Node.js가 제공하는 REPL을 사용하면 간단한 자바스크립트 코드를 실행해 결과를 확인해볼 수 있다.

```
$ node // 프롬프트 활성화
$ node index.js // 자바스크립트 파일 실행(파일 확장자 생략 가능)
```

## 3.4 비주얼 스튜디오 코드

### 3.4.1 비주얼 스튜디오 코드 설치

코드 에디터를 사용하면 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다.

### 3.4.2 내장 터미널

VS Code에는 터미널이 내장되어 있다. (단축키 Ctrl + `)

### 3.4.3 Code Runner 확장 플러그인

Code Runner 확장 플러그인을 사용하면 VS Code의 내장 터미널에서 단축키를 사용해 자바스크립트를 비롯해 다양한 프로그래밍 언어로 구현된 소스코드를 간단히 실행할 수 있다.

control + option + N 단축키를 사용해 현재 표시 중인 자바스크립트 파일을 실행할 수 있다.

Code Runner 확장 플러그인은 Node.js 환경을 사용해 자바스크립트를 실행한다. 따라서 클라이언트 사이드 Web API 가 포함된 소스코드는 Code Runner 확장 플러그인이 아닌 브라우저 환경에서 실행해야 한다.

### 3.4.4 Live Server 확장 플러그인

클라이언트 사이드 Web API가 포함된 자바스크립트 코드를 실행하려면 개발자 도구의 콘솔에서 실행하거나 자바스크립트 코드를 HTML에 삽입한 다음 HTML 파일을 브라우저에서 열어야 한다.

이때, Live Server 확장 플러그인을 사용하면 소스코드를 수정할 때마다 수정 사항을 브라우저에 자동으로 반영해주기 때무에 매우 편리하다.

`Go Live` 버튼을 클릭하면 가상 서버가 기동되어 브라우저에 HTML 파일이 자동 로딩된다. 이후 소스코드를 수정하면 수정 사항이 가상 서버에 자동으로 반영된다.

# 04장. 변수
## 4.1 변수란 무엇인가? 왜 필요한가?

> **변수란?** 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.
> 
- **변수에 여러 개의 값을 저장하는 방법**
    
    ```jsx
    var userId = 1;
    var userName = 'Lee';
    
    var user = {id: 1, name: 'Lee'};
    
    var users = [
    	{ id: 1, name: 'Lee' },
    	{ id: 2, name: 'Jung' }
    ]
    ```
    
    1. 여러개의 변수
    2. 배열
    3. 객체
- **변수 이름**  - 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- **변수 값 -** 변수에 저장된 값
- **할당(대입, 저장)** - 변수의 값을 저장
- **참조 -** 변수에 저장된 값을 읽어 들이는 것

## 4.2 식별자

> **식별자란(identifier)?** 어떤 값을 구별해서 식별할 수 있는 고유한 이름
> 
- 식별자는 값이 아니라 메모리 주소를 기억한다.

## 4.3 변수 선언

- 변수를 생성하는 것(값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비)
- 변수를 사용하려면 반드시 선언이 필요하다.
    - 선언하지 않은 식별자에 접근하는 경우 `ReferenceError` 가 발생한다.
- 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

```jsx
var score;
```

변수를 선언한 이후 변수에 값을 할당하지 않으면 확보된 메모리 공간 안에는 `undefined` 라는 값이 암묵적으로 할당되어 초기화된다. 

### 변수 선언의 단계

1. **선언 단계**
2. **초기화 단계** 
    - 변수가 선언된 이후 최초로 값을 할당하는 것
    - `var` 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 `undefined` 값을 가진다.

### 변수 이름은 어디에 등록되는가?

- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.

#### 실행 컨텍스트

> 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 식별자와 스코프를 관리한다.
> 

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // 1(실행 순서)

var score; // 2(실행 순서)
```

위 코드는 참조에러가 발생할 것 같지만 실제로 `undefined` 가 출력된다.

→ **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.** 

### 변수 호이스팅(variable hoisting)

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
- 모든 선언문은 런타임 이전 단계에서 먼저 실행된다.

## 4.5 값의 할당

- 할당 연산자 `=` 을 사용하여 변수에 값을 할당한다.

```javascript
var score;
score = 80;

var score = 80;
```

- 변수 선언 → 런타임 이전에 먼저 실행
- 값의 할당 → 소스코드가 순차적으로 실행되는 시점인 런타임에 실행

```jsx
console.log(score); // undefined

var score = 80;

console.log(score); // 80
```

```jsx
console.log(score); // undefined

score = 80;

var score;

console.log(score); // 80
```

## 4.6 값의 재할당

```jsx
var score = 80;

score = 70;
```

- `var` 키워드로 선언한 변수는 값을 재할당할 수 있다.
- 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.
- 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다.

### 가비지 콜렉터(garbage collector)

> 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. (어떤 식별자도 참조하지 않는 메모리 공간)
> 

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

### 예약어

> 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 
Ex. `await`, `break`, `case` 등
> 

### 예제

- 쉼표(,)로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있다.

```jsx
var person, $elem, _name, first_name, val1;
```

- ES5부터 식별자를 만들때 유니코드 문자를 허용한다.

```jsx
var 이름;
```

- 자바스크립트는 대소문자를 구별하므로 다음은 각각 별개의 변수다.

```jsx
var firstname;
var firstName;
var FIRSTNAME;
```

- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

### 네이밍 컨벤션

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리안 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

- 자바스크립트에서는 일반적으로 변수나 함수에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.

# 05장. 표현식과 문

## 5.1 값

> 값은 **식(표현식-expression)이 평가(evaluate)되어 생성된 결과**를 말한다.
> 
- 변수에 할당되는 것은 값이다.

```jsx
var sum = 10 + 20;
```

## 5.2 리터럴

> 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(`’’`, `""`, `.`, `[]`, `{}`, `//` 등)를 사용해 값을 생성하는 표기법을 말한다.
> 

```jsx
// 숫자 리터럴 3
3
```

- 자바스크립트 엔진은 코드가 실행되는 시점인 **런타임**에 리터럴을 평가해 값을 생성한다.

## 5.3 표현식

> 표현식(expression)은 **값으로 평가될 수 있는 문**(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
> 

```jsx
// 리터럴과 연산자로 이루어져도 평가되어 숫자 값 100을 생성하므로 표현식
var score = 50 + 50;
// 변수 식별자를 참조시 변수 값으로 평가
score;
```

- **표현식 종류**
    - 리터럴 표현식
    - 식별자 표현식(선언이 이미 존재한다고 가정)
    - 연산자 표현식
    - 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
- 표현식과 표현식이 평가된 값은 동치 관계이므로 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.

## 5.4 문

> 문(statement)는 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
> 
- 문의 집합이 프로그램이다.
- 문은 토큰(token)으로 구성된다.
    - 토큰 - 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
        - 키워드
        - 식별자
        - 연산자
        - 리터럴
        - 세미콜론
        - 마침표
        - 특수기호
- **문의 구분**
    - 선언문 - `var x;`
    - 할당문 - `x = 5;`
    - 함수 선언문 - `function foo () {}`
    - 조건문 - `if (x > 1) { return; }`
    - 반복문 - `for (var i = 0; i < 2; i++) { return; }`
    

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(`;`)
    - 문의 종료를 나타낸다.
    - 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
    - 코드 블록(`{ ... }`) 뒤에는 세미콜론을 붙이지 않는다. → 언제나 문의 종료를 의미하는 자체 종결성을 가지기 때문이다.
    - 문의 끝에 붙이는 세미콜론은 옵션이다. → 세미콜론 자동 삽입 기능(ASI)이 암묵적으로 수행되기 떄문이다.

## 5.6 표현식인 문과 표현식이 아닌 문

- **표현식인 문과 표현식이 아닌 문 구분하는 방법**
    - **표현식인 문** - 값으로 평가될 수 있는 문
    - **표현식이 아닌 문** - 값으로 평가될 수 없는 문
    
    → **변수에 할당**해봐서 구분하는 것이 가장 간단한 방법이다. 
    

```jsx
// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo);
```

- **완료 값(completion value)**
    - 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined` 를 출력한다. 이를 완료 값이라고 한다.
    - 표현식의 평가 결과가 아니므로 변수에 할당할 수 없고 참조할 수도 없다.

# 06장. 데이터 타입

- 데이터 타입은 값의 종류를 말한다.
- 자바스크립트의 모든 값은 데이터 타입을 갖는다.
- ES6는 **7개의 데이터 타입**(원시 타입/객체 타입)을 제공한다.

| 구분 | 데이터 타입 | 설명 |
| --- | --- | --- |
| 원시 타입 | 숫자 타입(Number) | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|  | 문자열 타입(String) | 문자열 |
|  | 불리언(boolean) 타입 | 논리적 참(true)과 거짓(false) |
|  | undefined 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
|  | null 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
|  | 심벌 타입(simbol) | ES6에서 추가된 7번째 타입 |
| 객체 타입 |  | 객체, 함수, 배열 등 |

## 6.1 숫자 타입

ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다. → **모든 수를 실수로 처리**하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다. 

```jsx
var integer = 10;
var double = 10.12;
var negative = -20
```

정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 

```jsx
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;

// --> 이들 값은 모두 10진수로 해석되어 65가 된다. 
```

정수만을 위한 타입이 없고 모두 실수로 처리된다. 

```jsx
console.log(1 === 1.0); // true
```

숫자 타입은 추가적으로 3가지 특별한 값을 표현할 수 있다.

- `Infinity` - 양의 무한대
- `-Infinity` - 음의 무한대
- `NaN` - 산술 연산 불가(not-a-number)
    - 자바스크립트는 대소문자를 구별하므로 `NAN`, `Nan`, `nan` 이라고 표기하지 않도록 주의한다.

```jsx
console.log(10 / 0)       // Infinity
console.log(10 / -0)      // -Infinity
console.log(1 * 'String') // NaN
```

`Number` 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 -1 보다 큰 정수를 표현할 수 있는 내장 객체 `BigInt` 가 있다. 

```jsx
const theBiggestInt = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
```

`BigInt` 는 내장 `Math` 객체의 메서드와 함께 사용할 수 없고 연산에서 `Number` 와 혼합해서 사용할 수 없다. 

## 6.2 문자열 타입

- 텍스트 데이터를 나타내는 데 사용한다.
- 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16) 의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.
- **작은 따옴표(’’), 큰 따옴표(””), 백틱(``)→ES6** 으로 텍스트를 감싼다.
- Immutable value → 11장에서

```jsx
var string;
string = 'string';
string = "string";
string = `string`;
```

문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다. 

따옴표로 문자열을 감싸지 않는다면 스페이스와 같은 공백 문자도 포함시킬 수 없다. 

## 6.3 템플릿 리터럴

- ES6 부터 도입
- **멀티라인 문자열, 표현식 삽입, 태그드 템플릿** 등 편리한 문자열 처리 기능을 제공한다.
- 템플릿 리터럴은 **런타임에 일반 문자열로 변환**되어 처리된다.
- **백틱(``)**을 사용해 표현한다.

```jsx
var ab = 123;
var template = `Template Literal ${ab}`;
console.log(template);
```

### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 줄바꿈이 허용되지 않는다. → **이스케이프 시퀀스**를 사용해야 한다. 

| 이스케이프 시퀀스 | 의미 |
| --- | --- |
| `\0` | Null |
| `\b` | 백스페이스 |
| `\f` | 폼 피드: 프린터로 출력할 경우 다음 페이지의 시작 지점으로 이동한다. |
| `\n` | 개행: 다음 행으로 이동 |
| `\r` | 개행: 커서를 처음으로 이동  |
| `\t` | 탭(수평) |
| `\v` | 탭(수직) |
| `\uXXXX` | 유니코드, 예를 들어 ‘\u0041’ 은 ‘A’ |
| `\’` | 작은 따옴표 |
| `\”` | 큰 따옴표 |
| `\\`  | 백슬래시 |

일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며 공백도 그대로 적용된다. 

### 6.3.2 표현식 삽입

```jsx
var first = 'Su-yeon';
var last = 'Jung';

console.log(`My name is ${first} ${last}.`); // My name is Su-yeon Jung.
```

표현식을 삽입하려면 `${}` 으로 표현식을 감싼다. 표현식의 평가 결과가 문자열이 아니어도 문자열로 타입이 강제로 변환되어 삽입된다. 

## 6.4 불리언 타입

- `true` - 참
- `false` - 거짓

```jsx
var foo = true;
var boo = false;
```

## 6.5 `undefined` 타입

- undefined 타입의 값은 undefined 가 유일하다.
- `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화 된다.

```jsx
var foo;
console.log(foo); // undefined
```

- 변수를 선언한 이후에 값을 할당하지 않은 변수를 참조하면 `undefined` 가 반환된다.
- **변수에 값이 없다는 것을 명시하고 싶을 때는 `null` 을 할당해야 한다.**

## 6.6 `null` 타입

- null 타입의 값은 null이 유일하다.
- 자바스크립트는 대소문자를 구분하므로 null은 Null, NULL 등과 다르다.
- 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.

## 6.7 심벌 타입

- 변경 불가능한 원시 타입의 값이다.
- 다른 값과 중복되지 않는 유일무이한 값이다.
- 주로, 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
- `Symbol` 함수를 호출해 생성한다.

```jsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

var obj = {};

obj[key] = 'value';
```

## 6.8 객체 타입

- 6가지 데이터 타입 이외의 값은 모두 객체 타입이다.
- 자바스크립트를 이루고 있는 거의 모든 것이 객체다.

## 6.9 데이터 타입의 필요성

1. 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
2. 값을 참조할 때 한 번에 읽어들여야 할 **메모리 공간의 크기**를 결정하기 위해 
3. 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
- 값을 참조할때도 데이터 타입 크기만큼의 값을 읽어 들인다.

### 6.9.2 데이터 타입에 의한 값의 해석

- 모든 값은 데이터 타입을 가지며, 메모리에 2진수(비트의 나열)로 저장된다.
- 2진수 값을 데이터 타입에 따라 다르게 해석한다.

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

- **정적 타입 언어**
    - 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
    - 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다.
        
        → 타입 체크를 통과하지 못하면 에러를 발생시키고 프로그램의 실행 자체를 막는다. 
        
    - 예시 - C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등
- **동적 타입 언어**
    - 변수를 선언할 때 타입을 선언하지 않는다.
    - 변수에 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
    - 예시 - JavaScript, Python, Ruby, PHP, Lisp, Perl 등
    
    ```jsx
    var foo;
    console.log(typeof foo); // undefined
    
    foo = 3;
    console.log(typeof foo); // number
    
    foo = 'hello';
    console.log(typeof foo); // string
    
    foo = true;
    console.log(typeof foo); // boolean
    
    foo = null;
    console.log(typeof foo); // null
    
    foo = Symbol();
    console.log(typeof foo); // symbol
    
    foo = {}; // 객체
    console.log(typeof foo); // object
    
    foo = []; // 배열 
    console.log(typeof foo); // object
    
    foo = function () {}; // 함수
    console.log(typeof foo); // function
    
    ```
    
    `typeof` 연산자는 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한다. 
    
    <aside>
    💡 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. → 동적 타이핑
    
    </aside>
- 연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- **연산자** - 피연산자를 연산하여 새로운 값을 만드는 역할
- **피연산자** - 연산의 대상 → 값으로 평가될 수 있는 표현식이어야 한다.
- 피연산자와 연산자의 조합으로 이뤄진연산자 표현식도 값으로 평가될 수 있는 표현식이다.

```jsx
// 산술 연산자
5 * 4 // -> 20

// 문자열 연결 연산자
'My name is' + ' Jung' // 'My name is Jung'

// 할당 연산자 
color = 'red' // -> 'red'

// 비교 연산자
3 > 5 // -> false

// 논리 연산자
true && false // -> false

// 타입 연산자 
typeof 'Hi' // -> string
```

# 07장. 연산자
## 7.1 산술 연산자

> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
> 
- 산술 연산이 불가능한 경우, `NaN` 을 반환한다.
- 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

<aside>
💡 부수효과란? 연산자가 피연산자의 값을 변경하는 현상
</aside>

### 7.1.1 이항 산술 연산자

> 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.
> 

| 이항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| + | 덧셈 | X |
| - | 뺄셈 | X |
| * | 곱셈 | X |
| / | 나눗셈 | X |
| % | 나머지 | X |

### 7.1.2 단항 산술 연산자

> 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
> 

| 단항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| ++ | 증가 | O |
| — | 감소 | O |
| + | 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. | X |
| - | 양수를 음수로, 음수를 양수로 반전한 값을 반환한다. | X |
- **증가/감소(`++`/ `--`) 연산자의 위치**
    - 전위 → 먼저 피연산자의 값을 증가/감소 시킨 후, 다른 연산을 수행
    - 후위 → 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소

```jsx
var x = 5, result;

// 선할당 후증가(postfix increment operator)
result = x++;
console.log(result, x); // 5, 6

// 선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); // 7, 7

// 선할당 후감소(postfix decrement operator)
result = x--;
console.log(result, x); // 7, 6

// 선감소 후할당(prefix decrement operator)
result = --x; 
console.log(result, x); // 5, 5
```

단항 연산자는 어떠한 효과도 없다. 

```jsx
+10;    // -> 10
+(-10); // -> -10
-(-10); // -> 10 부호를 반전한 값을 반환
```

숫자 타입이 아닌 피연산자에 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```jsx
var x = '1';

// 문자열을 숫자로 타입 변한
console.log(+x); // 1
// 부수 효과 없음
console.log(x); // '1'

// 불리언 값을 숫자로 타입 변환
x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // true

// 문자열을 숫자 타입 변환할 수 없으므로  NaN 반환
x = 'Hello'
console.log(+x); // NaN
// 부수 효과는 없다.
console.log(x); // "Hello"

-'10'; // -10

-true; // -1

-'Hello'; // NaN
```

### 7.1.3 문자열 연결 연산자

> `**+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.  그 외의 경우는 산술 연산자로 동작한다.**
> 

```jsx
// 문자열 연결 연산자
'1' + 2; // -> '12'
1+ '2'; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환
1 + true; // -> 2

// false는 0으로 타입 변환
1 + false; // -> 1

// null은 0으로 타입 변환
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // -> NaN
1 + undefined; // -> NaN
```

## 7.2 할당 연산자

> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
> 
- 좌항의 변수에 값을 할당하므로 변수 값이 변하는 **부수 효과**가 있다.

| 할당 연산자 | 예 | 동일 표현 | 부수 효과 |
| --- | --- | --- | --- |
| = | x = 5 | x = 5 | O |
| += | x += 5 | x = x + 5 | O |
| -= | x -= 5 | x = x - 5 | O |
| *= | x *= 5 | x = x * 5 | O |
| /= | x /= 5 | x = x / 5 | O |
| %=  | x %= 5 | x = x % 5 | O |
- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

```jsx
var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// 1. c = 0 : 0으로 평가
// 2. b = 0 : 0으로 평가
// 3. a = 0 : 0으로 평가
a = b = c = 0;

console.log(a, b, c); // 0 0 0 
```

할당문을 다른 변수에 할당할 수도 있다.

## 7.3 비교 연산자

> 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.
> 
- `if` 문이나 `for` 문과 같은 제어문의 조건식에서 주로 사용된다.

### 7.3.1 동등/일치 비교 연산자

> 동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.
> 
- 동등 비교 연산자 → **느슨한 비교**
- 일치 비교 연산자 → **엄격한 비교**

| 비교 연산자 | 의미 | 사례 | 설명 | 부수 효과 |
| --- | --- | --- | --- | --- |
| == | 동등 비교 | x == y | x와 y의 값이 같음 | X |
| === | 일치 비교 | x === y | x와 y의 값과 타입이 같음 | X |
| != | 부동등 비교 | x != y | x와 y의 값이 다름 | X |
| !== | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | X |

동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨후 같은 값인지 비교한다. 

```jsx
// 동등 비교
5 == 5; // true

// 암묵적 타입 변환을 통해 타입을 일치시키면 동등
5 == '5'; // true
```

동등 비교 연산자는 결과를 예측하기 어렵고 실수하기 쉬우므로 대신 일치 비교 연산자를 사용하는 편이 좋다. 

일치 비교 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 `true` 를 반환한다. (암묵적 타입 변환 하지 않음)

```jsx
// 일치 비교
5 === 5; // true

// 암묵적 타입 변환을 하지 않고 값을 비교
5 === '5'; // false
```

일치 비교 연산자는 `NaN` 을 주의해야 한다.

```jsx
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false
```

따라서 숫자가 `NaN`인지 조사하려면 빌트인 함수 `isNaN`을 써야 한다. 

```jsx
isNaN(NaN); // true
isNaN(10);  // false
isNaN(1 + undefined); // true
```

양의 0과 음의 0을 비교하면 `true` 를 반환한다.

```jsx
0 === -0 // true
0 == -0  // true
```

<aside>
💡 Object.is 메서드 <br>
ES6 에서 도입된 Object.is 메서드는 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자와 동일하게 동작한다.

</aside>

부동등 비교 연산자와 불일치 비교 연산자는 각각 동등 비교 연산자와 일치 비교 연산자의 반대 개념이다. 

```jsx
// 부동등 비교
5 != 8;   // true
5 != 5;   // false
5 != '5'; // false

// 불일치 비교
5 !== 8;   // true
5 !== 5;   // false
5 !== '5'; // true 
```

### 7.3.2 대소 관계 비교 연산자

> 피연산자의 크기를 비교하여 불리언 값을 반환한다.
> 

| 대소 관계 비교 연산자 | 예제 | 설명 | 부수 효과 |
| --- | --- | --- | --- |
| > | x > y | x가 y보다 크다 | X |
| < | x < y | x가 y보다 작다 | X |
| >= | x >= y | x가 y보다 크거나 같다 | X |
| <= | x <= y | x가 y보다 작거나 같다 | X |

## 7.4 삼항 조건 연산자

> 조건식의 평가 결과에 따라 반환할 값을 결정한다.
> 

```jsx
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

- 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다.
- 조건식이 참이면 콜론 앞의 두 번째 피연산자가 평가되어 반환되고, 거짓이면 콜론 뒤의 세 번째 피연산자가 평가되어 반환된다.

```jsx
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다. 
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

`if...else` 문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리할 수 있다. 

```jsx
var x = 2, result;

if(x % 2) result = '홀수';
else result = '짝수';

console.log(result); // 짝수
```

`if...else` 문이 값으로 사용할 수 없는 것과 달리 **삼항 조건 연산자 표현식은 값으로 사용**할 수 있다. 

따라서, 조건에 따라 어던 값을 결정해야 한다면 `if...else` 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. 하지만, 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면 `if...else` 문이 가독성이 더 좋다. 

## 7.5 논리 연산자

> 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.
> 

| 논리 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| ||  | 논리합(OR) | X |
| && | 논리곱(AND) | X |
| ! | 부정(NOT) | X |

```jsx
// 논리합(OR) 연산자
true || true;   // true
true || false;  // true
false || true;  // true
false || false; // false

// 논리곱(AND) 연산자
true && true;   // true
true && false;  // false
false && true;  // false
false && false; // false

// 부정(NOT) 연산자
!true;  // false
!false; // true
```

논리 부정 연산자는 언제나 불리언 값을 반환하는데 피연산자가 반드시 불리언 값일 필요는 없다. 피연산자가 불리언 타입이 아니면 암묵적으로 타입이 불리언으로 변환된다. 

```jsx
// 암묵적 타입 변환
!0;       // true
!'Hello'; // false
```

논리합 또는 논리곱 연산자의 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다. → 9장 단축평가에서 자세히...

## 7.6 쉼표 연산자

> 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가결과를 반환한다.
> 

```jsx
var x, y, z;

x = 1, y = 2, z = 3; // 3
```

## 7.7 그룹 연산자

> 소괄호(`()`)로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.
> 
- **그룹 연산자는 우선순위가 가장 높다.**

```jsx
10 * (2 + 3); // 50
```

## 7.8 `typeof` 연산자

> 피연산자의 데이터 타입을 문자열로 반환한다.
> 
1. string
2. number
3. boolean
4. undefined
5. symbol
6. object
7. function
- `typeof` 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다.
- `**typeof` 연산자로 `null` 값을 연산해보면 `null` 이 아닌 `object` 를 반환한다.  → 값이 `null` 인지 확인할 때는 일치 연산자를 활용**
- **선언하지 않은 식별자를 `typeof` 연산자로 연산해 보면 `ReferenceError` 가 발생하지 않고 `undefined` 가 반환된다.**

```jsx
typeof undeclared; // undefined
```

## 7.9 지수 연산자

> ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
> 

지수 연산자가 도입되기 이전에는 `Math.pow` 메서드를 사용했다. 

```jsx
2 ** 2;           // 4
Math.pow(2, 2);   // 4
2 ** 2.5;         // 5.6...
Math.pow(2, 2.5); // 5.6...
2 ** -2;          // 0.25
Math.pow(2, -2);  // 0.25
```

음수를 거듭제곱의 밑으로 사용해 계산하려면 다음과 같이 괄호로 묶어야 한다.

```jsx
(-5) ** 2; // 25
```

지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.

```jsx
var num = 5;
num **= 2; // 25
```

## 7.10 그 외의 연산자

| 연산자 | 개요 |
| --- | --- |
| ?. | 옵셔널 체이닝 연산자 |
| ?? | null 병합 연산자 |
| delete | 프로퍼티 삭제 |
| new | 생성자 함수를 호출할 때 사용하여 인스턴스 생성 |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
| in | 프로퍼티 존재 확인 |

## 7.11 연산자의 부수 효과

- 부수 효과가 있는 연산자
    - 할당 연산자(`=`)
    - 증가/감소 연산자(`++`/ `—`)
    - `delete` 연산자

## 7.12 연산자 우선순위

| 우선순위 | 연산자 |
| --- | --- |
| 1 | () |
| 2 | new(매개변수 존재), . , [] (프로퍼티 접근), () (함수 호출), ?. (옵셔널 체이닝 연산자) |
| 3 | new (매개변수 미존재) |
| 4 | x++, x— |
| 5 | !x, +x, -x, ++x, —-x, typeof, delete |
| 6 | **(이항 연산자 중에서 우선순위가 가장 높다) |
| 7 | *, /, % |
| 8 | +, -  |
| 9 | <, <=, >, >=, in, instanceof |
| 10 | ==, !=, ===, !== |
| 11 | ??(null 병합 연산자) |
| 12 | && |
| 13 | || |
| 14 | ? ... : ... |
| 15 | 할당 연산자(=, +=, -=, ...) |
| 16 | , |

연산자는 종류가 많아서 연산자 우선순위를 모두 기억하기 어렵고 실수하기 쉬우므로 기억에 의존하기보다 연산자 우선순위가 가장 높은 그룹 연산자를 활용해 우선순위를 명시적으로 조절하는 것을 권장한다. 

## 7.13 연산자 결합 순서

> 연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서
> 

| 결합 순서 | 연산자 |
| --- | --- |
| 좌항 → 우항  | +, =, /, %, <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof |
| 우항 → 좌항 | ++, —, 할당 연산자(=, +=, -=, ...), !x, +x, -x, ++x, —x, typeof, delete, ? ... : ... |



# 08장. 제어문

제어문(control flow statement)은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 

## 8.1 블록문

> 블록문(block statement/compound statement)은 0개 이상의 문을 중괄호로 묶은 것 → 코드 블록 혹은 블록
> 
- 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.
- 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 가지므로 끝에 세미콜론을 붙이지 않는다.

```jsx
// 블록문
{
	var foo = 10;
}

// 제어문
var x = 1;
if(x < 10) {
	x++;
}

// 함수 선언문
function sum(a, b){
	return a + b;
}
```

## 8.2 조건문

> 조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다.
> 
- 조건식은 불리언 값으로 평가될 수 있는 표현식

### 8.2.1 `if...else` 문

- 주어진 조건식의 평가 결과가 논리적 참 또는 거짓인지에 따라 실행할 코드 블록을 결정한다.

```jsx
if (조건식) {
	// 조건식이 참이면 이 코드 블록이 실행
} else {
	// 조건식이 거짓이면 이 코드 블록이 실행
}
```

조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다. 

```jsx
if (조건식1) {
	// 조건식1이 참이면 이 코드 블록 실행
} else if(조건식2){
	// 조건식2가 참이면 이 코드 블록 실행
} else {
	// 조건식1과 조건식2 모두 거짓이면 이 코드 블록 실행
}
```

`else if` , `else` 문은 옵션이다. `else if` 문은 여러 번 작성할 수 있다.

코드 블록 내의 문이 하나뿐이면 중괄호를 생략할 수 있다.

```jsx
var result = 조건식 ? <조건식이 true일 때> : <조건식이 false일 때>;
```

`if...else` 문은 삼항 조건 연산자로 바꿔 쓸 수 있다. → 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우에 좋다. 

### 8.2.2 `switch` 문

> `switch` 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 `case` 문으로 실행 흐름을 옮긴다.
> 

```jsx
switch(표현식){
	case 표현식1:
		switch 문의 표현식과 표현식1이 일치하면 실행될 문;
		break;
	case 표현식2:
		switch 문의 표현식과 표현식2가 일치하면 실행될 문;
		break;
	default:
		switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
}
```

- `default` 문은 선택사항으로, 사용할 수도 있고 사용하지 않을 수도 있다.
- `switch` 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.
- **폴스루(fall through)** - `switch` 문을 탈출하지 않고 `switch` 문이 끝날 때까지 이후의 모든 `case` 문과 `default` 문을 실행하는 현상
- `default` 문에는 `break` 문을 생략하는 것이 일반적이다. → 맨 마지막에 위치하므로 어차피 `switch` 문을 빠져나가게 된다.

## 8.3 반복문

> 반복문(loop statement)은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.
> 
- **종류**
    - `for` 문
    - `while` 문
    - `do...while` 문

### 8.3.1 `for` 문

- 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. **(반복 횟수가 명확할 때 주로 사용)**

```jsx
for(변수 선언문 또는 할당문; 조건식; 증감식){
	조건식이 참인 경우 반복 실행될 문;
}
```

- **실행 순서**
    1. 변수 선언문 또는 할당문
    2. 조건식 평가
    3. 조건식 평가 결과가 참인 경우 코드 블록 실행
    4. 증감식
    5. 조건식 평가
    6. 코드 블록 실행 
    7. 증감식
    
    ...(조건식이 false 일 때 까지 반복)
    
- `for` 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. → 어떠한 것도 선언하지 않으면 무한루프

```jsx
for(;;){
	...
}
```

### 8.3.2 `while` 문

- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. **(반복 횟수가 불명확할 때 주로 사용)**
- **동작**
    
    조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료
    
    조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환
    
- 조건식의 평가 결과가 언제나 참이면 무한루프

```jsx
while(true) { ... }
```

### 8.3.3 `do...while` 문

- **동작**
    
    코드 블록을 먼저 실행하고 조건식을 평가 → 코드 블록은 무조건 한 번 이상 실행
    

```jsx
var count = 0;

do {
	console.log(count); // 0 1 2
	count++;
} while (count < 3);
```

## 8.4 `break` 문

- 레이블 문, 반복문(`for`, `for...in`, `for...of`, `while`, `do...while`) 또는 `switch` 문의 코드 블록을 탈출할 때 사용 → 이 코드 블록들 외에서 `break` 문을 사용하면 `SyntaxError`(문법 에러) 가 발생
- 레이블 문 사용 예시

```jsx
outer: for(var i = 0; i < 3; i++){
	for(var j = 0; j < 3; j++){
		if( i + j == 3 ) break outer;
	}
}
```

## 8.5 `continue` 문

`continue` 문은 반복문의 코드 블록 실행을 **현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동**시킨다.

<br/>


# 09장. 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- 명시적 타입 변환(타입 캐스팅) : 개발자가 의도적으로 값의 타입을 변환하는 것
- 암묵적 타입 변환(타입 강제 변환) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 것

```jsx
var x = 10;

var str_explicit = x.toString();
console.log(typeof str_explicit, str_explicit); // string 10

var str_implicit = x + ' ';
console.log(typeof str_implicit, str_implicit); // string 10
```

자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 단 한 번 사용하고 버린다. (명시적 타입 변환이나 암묵적 타입 변환이 기존 원시값을 직접 변경하는 것은 아니다.)

## 9.2 암묵적 타입 변환

```jsx
'10' + 2 // '102'

5 * '10' // 50

!0 // true
if(1) { } 
```

암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. 

### 9.2.1 문자열 타입으로 변환

```jsx
1 + '2' // "12"

`1 + 1 = ${1 + 1}` // "1 + 1 = 2"
```

→ 피연산자 중 하나 이상이 문자열이므로 `+` 연산자는 문자열 연결 연산자로 동작한다. 

자바스크립트 엔진이 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다. 

```jsx
// 숫자 타입
0 + '' // "0"
-0 + '' // "0"
1 + '' // "1"
-1 + '' // "-1"
NaN + '' // "NaN"
Infinity + '' // "Infinity"
-Infinity + '' // "-Infinity"

// 불리언 타입
true + '' // "true"
false + '' // "false"

// null 타입
null + '' // "null"

// undefined 타입
undefined + '' // "undefined"

// 심벌 타입
(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string

// 객체 타입
({}) + '' // "[object Object]"
Math + '' // "[object Math]"
[] + '' // ""
[10, 20] + '' // "10, 20"
(function(){}) + '' // "function(){}"
Array+ '' // "function Array() { [native code] }"
```

### 9.2.2 숫자 타입으로 변환

산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다. 

```jsx
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN
```

피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 `NaN`이 된다. 

비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드의 문맥상 모두 숫자 타입이어야 한다. 

```jsx
'1' > 0 // true
```

`+` 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다. 

```jsx
// 문자열 타입
+'' // 0
+'0' // 0
+'1' // 1
+'string' // NaN

// 불리언 타입
+true // 1
+false // 0

// null 타입
+null // 0

// undefined 타입
+undefined // NaN

// 심벌 타입
+Symbol() // TypeError: Cannot convert a Symbol value to a number

// 객체 타입
+{} // NaN
+[] // 0
+[10, 20] // NaN
+(function(){}) // NaN
```

### 9.2.3 불리언 타입으로 변환

if 문이나 for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값으로 평가되어야 하는 표현식이다. → 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. 

```jsx
if('') console.log('1');
if(true) console.log('2');
if(0) console.log('3');
if('str') console.log('4');
if(null) console.log('5');

// 2 4
```

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 

- Falsy 값
    - `false`
    - `undefined`
    - `null`
    - `0`, `-0`
    - `NaN`
    - `‘’` (빈문자열)

Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다. 

## 9.3 명시적 타입 변환

- 명시적으로 타입을 변경하는 방법
    - 표준 빌트인 생성자 함수(`String`, `Number`, `Boolean`)를 `new` 연산자 없이 호출하는 방법
    - 빌트인 메서들 사용하는 방법
    - 암묵적 타입 변환을 이용하는 방법

### 9.3.1 문자열 타입으로 변환

1. `String` 생성자 함수를 `new` 없이 호출하는 방법
2. `Object.prototype.toString` 메서드 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

### 9.3.2 숫자 타입으로 변환

1. `Number` 생성자 함수를 `new` 연산자 없이 호출하는 방법
2. `parseInt`, `parseFloat` 함수를 사용하는 방법
3. `+` 단항 산술 연산자를 이용하는 방법 
4. `*` 산술 연산자를 이용하는 방법

### 9.3.3 불리언 타입으로 변환

1. `Boolean` 생성자 함수를 `new` 연산자 없이 호출하는 방법
2. `!` 부정 논리 연산자를 두번 사용하는 방법

## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리곱 연산자(`&&`) → 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정
- 논리합 연산자(`||`) → 첫 번째 피연산자가 논리합 연산자 표현식의 평가 결과를 지정

→ 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. **“단축 평가”**

- **단축 평가**
    
    표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것
    
- **유용한 경우**
    1. 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined`가 아닌지 확인하고 프로퍼티를 참조할 때
    
    ```jsx
    var elem = null;
    var value = elem && elem.value; // null
    ```
    
    옵셔널 체이닝 연산자 `?.`은 좌항의 피연산자가 `null` 또는 `undefined` 인 경우 `undefined`를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. 
    
    ```jsx
    var elem = null;
    
    var value = elem?.value;
    console.log(value); // undefined
    ```
    
    1. 함수 매개변수에 기본값을 설정할 때
    
    함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 `undefined`가 할당된다. 
    
    ```jsx
    function getStringLength(str) {
    	str = str || '';
    	return str.length;
    }
    
    getStringLength(); // 0
    
    function getStringLength(str = ''){
    	return str.length;
    }
    ```
    

### 9.4.3 null 병합 연산자

좌항의 피연산자가 `null` 또는 `undefined`인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. → 변수에 기본값을 설정할 때 유용

# 10. 객체 리터럴

## 10.1 객체란

---

- 자바스크립트는 **“객체 기반"**의 프로그래밍 언어이다.
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

```jsx
var student = {
	major: 'CS',
	name: 'suyeon'
};
```

- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 **키와 값**으로 구성된다.

### 객체의 구성

- **프로퍼티** : 객체의 상태를 나타내는 값(data)
- **메서드** : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

## 10.2 객체 리터럴에 의한 객체 생성

---

- 자바스크립트는 프로토타입 기반 객체지향 언어
- **객체 생성 방법**
    - 객체 리터럴
        - 객체 리터럴은 값으로 평가되는 표현식으로 닫는 중괄호 뒤에 세미콜론을 붙인다.
    - Object 생성자 함수
    - 생성자 함수
    - Object.create 메서드
    - 클래스(ES6)

## 10.3 프로퍼티

---

> **객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**
> 
- 프로퍼티를 나열할 때는 쉼표로 구분한다.
- 프로퍼티키 → 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
    
    ⇒ 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다. 
    
    - 프로퍼티키를 동적으로 생성할 수 있는데 이 경우 프로퍼티 키로 사용할 표현식을 대괄호(`[]`)로 묶어야 한다.
    - 프로퍼티키에 문자열이나 심벌 값 외의 값을 사용하는 경우 암묵적 타입 변환을 통해 문자열이 된다.
    - 예약어를 프로퍼티키로 사용해도 에러가 발생하지 않는다.
    - 이미 존재하는 프로퍼티키를 중복 선언하면 나중에 선언한 프로퍼티가 덮어쓴다.
- 프로퍼티값 → 자바스크립트에서 사용할 수 있는 모든 값

## 10.4 메서드

---

- 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.
- 일반 함수와 구분하기 위해 객체에 묶여 있는 함수는 **메서드**라고 한다.

## 10.5 프로퍼티 접근

---

- **접근 방법**
    - 마침표 프로퍼티 접근 연산자(.)을 사용하는 마침표 표기법
    - 대괄호 프로퍼티 접근 연산자([ … ])를 사용하는 대괄호 표기법

```jsx
var person = {
	name: 'suyeon',
};

console.log(person.name);

console.log(person['name']);

console.log(person.age); // undefined
```

- 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 **따옴표로 감싼 문자열**을 쓴다.
- 프로퍼티키가 식별자 네이밍 규칙을 준수하지 않는다면 반드시 대괄호 표기법을 사용해야 한다.
- 객체에 존재하지 않는 프로퍼티에 접근하는 경우 `undefined`가 반환된다.

## 10.6 프로퍼티 값 갱신

---

```jsx
var person = {
	name: 'suyeon',
};

person.age = 25;

console.log(person); // {name: "suyeon", age: 25}
```

## 10.8 프로퍼티 삭제

---

- `delete` 연산자를 사용하여 객체의 프로퍼티를 삭제한다.
- 존재하지 않는 프로퍼티를 삭제한 경우 아무런 에러 없이 무시된다.

```jsx
var person = {
	name: 'suyeon',
};

delete person.age;

console.log(person); // {}
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

---

### 10.9.1 프로퍼티 축약 표현

```jsx
let x = 1, y = 2;

const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 **프로퍼티 키를 생략**할 수 있다. 

### 10.9.2 계산된 프로퍼티 이름

> 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 동적으로 생성된 프로퍼티 키
> 

```jsx
const prefix = 'prop';
let i = 0;

const obj = {
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

ES5에서는 계산된 프로퍼티 이름으로 프로퍼티 키를 동적으로 생성하려면 객체 리터럴 외부에서 대괄호 표기법을 사용해야 했다.

### 10.9.3 메서드 축약 표현

- ES5에서는 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.
- ES6에서는 메서드를 정의할 때 `function` 키워드를 생략한 축약 표현을 사용할 수 있다.

```jsx
const obj = {
	name: 'Lee',
	sayHi() {
		console.log("Hi");
	}
};

obj.sayHi(); // Hi
```

# 11장. 원시 값과 객체의 비교

## 데이터 타입

- 숫자
- 문자열
- 불리언
- `null`
- `undefined`
- 심벌
- 객체 타입

### 원시 타입(primitive type)

- 원시값은 변경 불가능한 값이다.
- 원시값을 변수에 할당하면 변수에는 **실제 값**이 저장된다.
- 원시값을 갖는 변수를 다른 변수에 할당하면 **원본의 원시값이 복사**되어 전달된다. (값에 의한 전달)

### 객체 타입(object/reference type)

- 객체 타입의 값은 변경 가능한 값이다.
- 객체를 변수에 할당하면 변수에는 **참조값**이 저장된다.
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사**되어 전달된다. (참조에 의한 전달)

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

> 한번 생성된 원시값은 읽기 전용(read only) 값으로 변경할 수 없다.
> 

```jsx
// 상수는 재할당이 금지된 변수
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있음
o.a = 1;
console.log(o); // {a: 1}
```

변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. **(불변성)**

### 11.1.2 문자열과 불변성

- 문자열은 0개 이상의 문자로 이루어진 집합
- 1개의 문자는 2바이트의 메모리 공간에 저장되며 문자열이 몇 개의 문자로 이뤄졌는지에 따라 필요한 메모리 공간의 크기가 결정된다.
- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

```jsx
var str = 'string';

str[0] = 'S';

console.log(str); // string
```

→ 문자열은 원시값이므로 변경할 수 없다. 

→ 하지만, 변수에 새로운 문자열을 재할당하는 것은 가능하다. 

### 11.1.3 값에 의한 전달

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 **원시값이 복사**되어 전달된다. 

```jsx
var score = 80;
var copy = score;
console.log(score, copy); // 80 80

score = 100;
console.log(score, copy); // 100 80
```

score 변수와 copy 변수는 같은 80 값을 가지더라도 **다른 메모리 공간에 저장된 별개의 값**이다.  → 원본 변수의 변경이 복사 변수에 영항을 미치지 않음

## 11.2 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않고, 동적으로 추가되고 삭제할 수 있다.
- 프로퍼티 값에 제약이 없다.

→ 객체는 원시값과 같이 확보해야 할 **메모리 공간의 크기를 사전에 정해 둘 수 없다.** 

```
자바, C++ 과 달리 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 
객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다. 
```

### 11.2.1 변경 가능한 값

> **객체 타입의 값, 즉 객체는 변경 가능한 값이다.**
> 

```jsx
var person = {
	name: 'suyeon'
};

console.log(person); // {name: 'suyeon'}

person.name = 'Suyeon';

person.age = 25;
```

- 객체를 할당한 변수를 참조하면 **메모리에 저장되어 있는 참조값을 통해 실제 객체에 접근**한다.
- 재할당 없이 **프로퍼티를 동적으로 추가**할 수도 있고 **프로퍼티 값을 갱신**할 수도 있으며 **프로퍼티 자체를 삭제**할 수도 있다.

- 왜 객체는 변경 가능한 값으로 설계?
    
    → 메모리를 효율적으로 사용하기 위해
    
    → 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해
    

### 11.2.2 참조에 의한 전달

```jsx
var person = {
	name: 'suyeon'
};

// "참조 값"을 복사(얕은 복사)
var copy = person;

console.log(copy === person); // true

copy.name = 'Suyeon';

console.log(person); // {name: 'Suyeon'}
```

→ 두 개의 식별자가 하나의 객체를 공유

# 12장. 함수

## 12.1 함수란?

> 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
> 
- 매개변수 ← 함수 내부로 입력을 전달받는 변수
- 인수 ← 입력
- 반환값 ← 출력

## 12.2 함수를 사용하는 이유

**“코드의 재사용”**

- 유지보수의 편의성 증대
- 코드의 신뢰성 높임

## 12.3 함수 리터럴

- **자바스크립트에서 함수는 ”객체 타입의 값”**
- 함수 리터럴의 구성요소
    
    
    | 구성요소 | 설명 |
    | --- | --- |
    | 함수 이름 | - 함수 이름은 식별자(식별자 네이밍 규칙 준수)
    - 함수 몸체 내에서만 참조할 수 있는 식별자
    - 함수 이름 생략 가능(기명 함수/익명 함수) |
    | 매개변수 목록 | - 0개 이상의 매개변수
    - 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당
    - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급 |
    | 함수 몸체 | - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행단위로 정의한 코드 블록
    - 함수 호출에 의해 실행 |

## 12.4 함수 정의

1. 함수 선언문
    - 함수 이름을 생략할 수 없다.
    - 함수 선언문은 표현식이 아닌 문이다. → 실행 시 완료 값 `undefined` 가 출력
    - 자바스크립트 엔진은 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
    - 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
    
    ```jsx
    function add(x, y) {
    	return x + y;
    }
    ```
    
2. 함수 표현식
    - 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
    
    ```jsx
    var add = function(x, y) {
    	return x + y;
    };
    ```
    
3. Function 생성자 함수
    - 클로저를 생성하지 않는다.
    - 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.
    
    → 바람직하지 않다!
    
    ```jsx
    var add = new Function('x', 'y', 'return x+y');
    ```
    
4. 화살표 함수(ES6)
    - 항상 익명 함수로 정의한다.
    - 기존 함수와 `this` 바인딩 방식이 다르다.
    - `prototype` 프로퍼티가 없고 `arguments` 객체를 생성하지 않는다.
    
    ```jsx
    var add = (x, y) => x + y;
    ```
    

### 12.4.3 함수 생성 시점과 함수 호이스팅

```jsx
// 함수 참조
console.log(add); // f add(x, y)
console.log(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

function add(x, y) {
	return x + y;
}

var sub = function(x, y) {
	return x - y;
}
```

**함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.** 

- 함수 선언문 → 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행 (함수 객체가 먼저 생성, 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당)

**⇒ 함수 호이스팅(함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징)**

- 함수 표현식 → 변수 할당문의 값은 할당문이 실행되는 시점(런타임)에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.

**⇒ 변수 호이스팅**

## 12.5 함수 호출

함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 

### 12.5.1 매개변수와 인수

- 인수는 값으로 평가될 수 있는 표현식이어야 한다.
- 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.
- 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. (스코프 - 함수 내부)
- 매개변수 개수 > 인수 개수 : 에러가 발생하지 않으며 인수가 할당되지 않은 변수는 `undefined` 로 초기화된다.
- 매개변수 개수 < 인수 개수 : 초과된 인수 무시, 암묵적으로 `arguments` 객체의 프로퍼티로 보관

### 12.5.2 인수 확인

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

**⇒ 함수 정의시 적절한 인수가 전달되었는지 확인할 필요가 있다.** 

### 12.5.3 매개변수의 최대 개수

매개변수의 최대 개수가 명시적으로 제한되어 있지는 않지만 이상적인 매개변수는 0개이며 적을수록 좋다. 

### 12.5.4 반환문

- 반환문은 `return` 키워드 뒤에 오는 표현식을 평가해 반환한다.
- 반환문은 생략할 수 있으며 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 `undefined`를 반환한다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시값 → 값에 의한 전달
- 객체 → 참조에 의한 전달

객체 타입의 값의 경우 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 **원본 객체가 변경되는 부수효과**가 발생한다. 

→ 옵저버 패턴

→ 객체를 불변 객체로 만들어 사용(깊은 복사)

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

> 함수 정의와 동시에 즉시 호출되는 함수(단 한번만 호출되며 다시 호출할 수 없음)
> 

```jsx
(function() {
	var a = 3;
	var b = 5;
	return a * b;
}());
```

- 즉시 실행 함수는 반드시 그룹 연산자 `(...)` 로 감싸야 한다.

### 12.7.2 재귀 함수

> 자기 자신을 호출하는 재귀 호출을 수행하는 함수
> 
- 함수 내부에서 함수 이름을 사용해 자기 자신을 호출 할 수 있으며 함수를 가리키는 식별자로도 재귀 호출할 수 있다.
- 탈출 조건이 없으면 함수가 무한 호출되어 스택 오버플로 에러가 발생한다.

### 12.7.3 중첩 함수

> 함수 내부에 정의된 함수를 중첩 함수 혹은 내부 함수라고 한다.
> 
- 외부 함수 : 중첩 함수를 포함하는 함수
- 외부 함수 내부에서만 호출할 수 있다.
- 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.

```jsx
function outer() {
	var x = 1;

	function inner() {
		var y = 2;
		console.log(x + y);
	}

	inner();
}

outer();
```

### 12.7.4 콜백 함수

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
> 
- 고차 함수 → 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
- 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

### 12.7.5 순수 함수와 비순수 함수

- 순수 함수 : 함수형 프로그래밍에서 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 부수효과가 없는 함수
- 비순수 함수 : 부수효과가 있는 함수


<br>

# 13장. 스코프

## 13.1 스코프란?

> - 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는데 이 **유효 범위를 스코프**라고 한다. 
- 식별자를 검색할 때 사용하는 규칙
- 네임스페이스
> 

```jsx
var x = 'global';

function foo() {
	var x = 'local';
	console.log(x); // local
}

foo();

console.log(x); // global
```

코드의 가장 바깥쪽 영역과 foo 함수 내부에 같은 이름을 갖는 `x` 변수가 있다. 

- 자바스크립트 엔진은 이름이 같은 2개의 변수 중에서 어떤 변수를 참조해야 할 것인기 결정하는 **“식별자 결정"**을 수행한다.
- 자바스크립트 엔진은 코드를 실행할 때 코드의 문맥(context)을 고려한다.

> **렉시컬 환경(lexical environment)**
코드가 어디서 실행되며 주변에 어떤 코드가 있는지 
- 전역 렉시컬 환경 : 코드가 로드되면 곧바로 생성
- 함수 렉시컬 환경 : 함수가 호출되면 곧바로 생성
> 

## 13.2 스코프의 종류

| 구분 | 설명 | 스코프 | 변수 |
| --- | --- | --- | --- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |

→ 변수는 **선언된 위치**에 의해 자신의 유효한 범위인 스코프가 결정된다. 

→ 전역 변수는 어디서든 참조할 수 있다. 

→ 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. 

### 13.2.2 지역과 지역 스코프

**지역 변수는 지역 스코프와 하위 지역 스코프에서 유효하다.** 

## 13.3 스코프 체인

> 스포크가 계층적으로 연결된 것
> 
- **중첩 함수(nested function)** : 함수 몸체 내부에서 정의한 함수
- **외부 함수(outer function)** : 중첩 함수를 포함하는 함수

→ 함수는 중첩될 수 있으며 이는 지역 스코프도 중첩될 수 있다는 의미이다. 

**→ 스코프가 함수의 중첩에 의해 계층적인 구조를 갖는다.** 

💡 **변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 “변수를 참조하는 코드의 스코프”에서 시작하여 “상위 스코프” 방향으로 이동하며 선언된 변수를 검색한다.** 

- 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다.
- 자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기에 앞서 **렉시컬 환경**을 실제로 생성한다.
- 변수 선언시 **변수 식별자는 이 자료구조의 키**, 변수 할당이 되면 이 자료구조의 **변수 식별자에 해당하는 값을 변경**한다.

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다!

```jsx
function foo() {
    console.log("global function foo");
}

function bar() {
    function foo() {
        console.log("local function foo");
    }
    foo();
}

bar(); // local function foo
```

→ 함수도 식별자에 할당되기 때문에 스코프를 갖는다. 

## 13.4 함수 레벨 스코프

> 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정 (if, for, while, try/catch 제외)
> 
- `var` 변수는 함수 레벨 스코프만 인정한다.

```jsx
var i = 10;

for(var i = 0; i < 5; i++){
	console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

## 13.5 렉시컬 스코프

```jsx
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // 1
bar(); // 1
```

1. **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정한다. → 동적 스코프
    - bar 함수의 상위 스코프 → foo 함수의 지역 스코프, 전역 스코프
2. **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프를 결정한다. → 렉시컬 스코프 or 정적 스코프
    - bar 함수의 상위 스코프 → 전역 스코프

> 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

<br>

# 14장. 전역 변수의 문제점

- 전역 변수의 문제점
- 전역 변수의 사용을 억제할 수 있는 방법

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- **생명 주기**
    1. 생성
    2. 할당
    3. 소멸
- **지역변수** → 함수가 호출되면 생성되고 함수가 종료하면 소멸 (함수의 생명주기와 일치)
- **전역변수** → 애플리케이션의 생명 주기와 일치

일반적으로 함수가 종료하면 함수가 생성하는 스코프도 소멸되지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하여 **“지역변수가 함수보다 오래 생존”**하는 경우가 있다. 

```jsx
var x = 'global';

function foo() {
	console.log(x); // (1) undefined
	var x = 'local';
}

foo();

console.log(x); // global
```

(1) `foo` 함수 내부 코드를 실행할 때 자바스크립트 엔진에 의해 선언문이 먼저 실행되므로 아직 할당이 안 된 상태, 즉 `undefined`가 반환됨

**→ 호이스팅은 스코프 단위로 동작**

> **호이스팅?**
변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징
> 

### 14.1.2 전역 변수의 생명 주기

전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없이 코드가 로드되자마자 곧바로 해석되고 실행된다. (더이상 실행할 문이 없을 때 종료)

> **전역 객체(global object)**
코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
- 클라이언트 사이드 환경 → `window`
- 서버 사이드 환경 → `global`
> 
- **전역 객체의 프로퍼티**
    - 표준 빌트인 객체(`Object`, `String`, `Number`, `Function`, `Array`…)
    - 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API)
    - `var` 키워드로 선언한 전역 변수와 전역 함수

## 14.2 전역 변수의 문제점

> **(1) 암묵적 결합(implicit coupling)**
모든 코드가 전역 변수를 참조하고 변경할 수 있음 → 코드 가독성 저해, 상태 변경 위험성 존재
> 

> **(2) 긴 생명 주기**
전역 변수는 생명 주기가 길어 메모리 리소스도 **오랜 기간 소비**
> 

`var` 키워드는 변수의 중복 선언을 허용하여 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있음 → 의도치 않은 재할당

> **(3) 스코프 체인 상에서 종점에 존재**
변수를 검색할 때 전역 변수가 가장 마지막에 검색되는데 이는 검색 속도가 가장 느리다는 것이다.
> 

> **(4) 네임스페이스 오염**
파일이 분리되어 있어도 하나의 전역 스코프를 공유하므로 예상치 못한 결과를 가져올 수 있다.
> 

## 14.3 전역 변수의 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야 할 이유를 찾지 못했다면 지역 변수 사용!
- 변수의 스코프는 좁을수록 좋다!

### 14.3.1 즉시 실행 함수

```jsx
(function () {
	var foo = 10; 
	// ...
}());

console.log(foo); // ReferenceError: foo is not defined
```

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 **즉시 실행 함수의 지역 변수**가 된다. 

### 14.3.2 네임스페이스 객체

```jsx
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee
```

네임스페이스를 계층적으로도 구성할 수 있다. (그다지 유용하지 않음)

### 14.3.3 모듈 패턴

클래스 형태를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방식

- 클로저 기반 동작
- 전역 변수의 억제
- 캡슐화 구현 가능

> **캡슐화**
객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것
> 
- 자바스크립트는 `public`, `private`, `protected` 와 같은 접근 제한자를 제공하지 않는다.

```jsx
var Counter = (function () {
	// private 변수
	var num = 0;

	// 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체 반환
	return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	}
}());

// private 변수는 외부로 노출되지 않음
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

- 반환되는 객체의 프로퍼티 → 퍼블릭 멤버(public member)
- 반환하는 객체에 추가하지 않은 변수나 함수 → 프라이빗 멤버(private member)

### 14.3.4 ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. → `var` 키워드로 선언한 변수는 더는 전역변수가 아니다. 

- **사용법**
    
    ```html
    <script type="module" src="lib.mjs"></script>
    ```
    
    - `type=”module”` 어트리뷰트 추가하면 로드된 자바스크립트 파일이 모듈로 동작
    - 모듈의 파일 확장자는 `mjs` 권장