<p align="center"><img src="https://simage.kyobobook.co.kr/images/book/large/766/l9788998139766.jpg"></p>

# 목차
- [1장. 협력하는 객체들의 공동체](#1---------------)
  * [역할과 책임](#------)
  * [역할, 책임, 협력](#----------)
    + [기능을 구현하기 위해 역할과 책임을 수행하며 협력하는 객체들](#---------------------------------)
  * [협력 속에 사는 객체](#-----------)
    + [상태와 행동을 함께 지닌 자율적인 객체](#---------------------)
    + [협력과 메시지](#-------)
    + [메서드와 자율성](#--------)
  * [객체지향의 본질](#--------)
- [2장. 이상한 나라의 객체](#2------------)
  * [객체, 그리고 이상한 나라](#--------------)
    + [앨리스 객체](#------)
  * [객체, 그리고 소프트웨어 나라](#----------------)
    + [상태](#--)
    + [행동](#--)
    + [식별자](#---)
  * [기계로서의 객체](#--------)
  * [행동이 상태를 결정한다](#------------)
  * [은유와 객체](#------)
- [3장. 타입과 추상화](#3---------)
  * [추상화를 통한 복잡성 극복](#--------------)
  * [객체지향과 추상화](#---------)
    + [개념의 세 가지 관점](#-----------)
    + [객체를 분류하기 위한 틀](#-------------)
    + [분류는 추상화를 위한 도구다](#---------------)
  * [타입](#--)
    + [데이터 타입](#------)
    + [객체와 타입](#------)
    + [행동이 우선이다](#--------)
  * [타입의 계층](#------)
    + [일반화/특수화 관계](#----------)
    + [슈퍼타입과 서브타입](#----------)
  * [정적 모델](#-----)
    + [타입의 목적](#------)
    + [결국 타입은 추상화다](#-----------)
    + [동적 모델과 정적 모델](#------------)
    + [클래스](#---)
- [4장. 역할, 책임, 협력](#4------------)
  * [협력](#--)
    + [요청하고 응답하며 협력하는 사람들](#------------------)
  * [책임](#--)
    + [책임의 분류](#------)
    + [책임과 메시지](#-------)
  * [역할](#--)
    + [책임의 집합이 의미하는 것](#--------------)
    + [협력의 추상화](#-------)
    + [대체 가능성](#------)
  * [객체의 모양을 결정하는 협력](#---------------)
    + [협력을 따라 흐르는 객체의 책임](#-----------------)
  * [객체지향 설계 기법](#----------)
    + [책임-주도 설계](#--------)
    + [디자인 패턴](#------)
    + [테스트-주도 개발](#---------)
- [5장. 책임과 메시지](#5---------)
  * [자율적인 책임](#-------)
    + [설계의 품질을 좌우하는 책임](#---------------)
    + [‘어떻게'가 아니라 ‘무엇'을](#----------------)
    + [책임을 자극하는 메시지](#------------)
  * [메시지와 메서드](#--------)
    + [메시지](#---)
    + [메서드](#---)
    + [다형성](#---)
    + [유연하고 확장 가능하고 재사용성이 높은 협력의 의미](#----------------------------)
    + [송신자와 수신자를 약하게 연결하는 메시지](#----------------------)
  * [메시지를 따라라](#--------)
    + [객체지향의 핵심, 메시지](#-------------)
    + [책임-주도 설계 다시 살펴보기](#----------------)
    + [What/Who 사이클](#what-who----)
    + [묻지 말고 시켜라(Tell, Don’t Ask, 데메테르 법칙)](#----------tell--don-t-ask----------)
    + [메시지를 믿어라](#--------)
  * [객체 인터페이스](#--------)
    + [인터페이스](#-----)
    + [메시지가 인터페이스를 결정한다](#----------------)
    + [공용 인터페이스](#--------)
  * [인터페이스와 구현의 분리](#-------------)
    + [객체 관점에서 생각하는 방법](#---------------)
    + [구현](#--)
    + [인터페이스와 구현의 분리 원칙](#----------------)
    + [캡슐화(정보 은닉)](#----------)
  * [책임의 자율성이 협력의 품질을 결정한다](#---------------------)
- [6장. 객체 지도](#6-------)
  * [기능 설계 대 구조 설계](#-------------)
  * [두 가지 재료: 기능과 구조](#---------------)
  * [안정적인 재료: 구조](#-----------)
    + [도메인 모델](#------)
    + [도메인의 모습을 담을 수 있는 객체지향](#---------------------)
    + [표현적 차이](#------)
    + [불안정한 기능을 담는 안정적인 도메인 모델](#-----------------------)
  * [불안정한 재료: 기능](#-----------)
    + [유스케이스](#-----)
    + [유스케이스는 설계 기법도, 객체지향 기법도 아니다](#---------------------------)
  * [재료 합치기: 기능과 구조의 통합](#------------------)
    + [도메인 모델, 유스케이스, 그리고 책임-주도 설계](#---------------------------)
    + [기능 변경을 흡수하는 안정적인 구조](#-------------------)
- [7장. 함께 모으기](#7--------)
  * [커피 전문점 도메인](#----------)
    + [커피 전문점이라는 세상](#------------)
  * [설계하고 구현하기](#---------)
    + [커피를 주문하기 위한 협력 찾기](#-----------------)
    + [인터페이스 정리하기](#----------)
    + [구현하기](#----)
  * [코드와 세 가지 관점](#-----------)
    + [코드는 세 가지 관점을 모두 제공해야 한다.](#-----------------------)
    + [도메인 개념을 참조하는 이유](#---------------)
    + [인터페이스와 구현을 분리하라](#---------------)


# 1장. 협력하는 객체들의 공동체

객체지향 패러다임의 핵심이 자율적인 객체들의 협력

## 역할과 책임

협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다. 

- 여러 객체가 동일한 역할을 수행할 수 있다.
- 역할은 대체 가능성을 의미한다. (substitutable)
- 각 객체는 책임을 수행하는 방법은 자율적으로 선택할 수 있다. (polymorphism)
- 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

## 역할, 책임, 협력

### 기능을 구현하기 위해 역할과 책임을 수행하며 협력하는 객체들

> 어떤 객체도 섬이 아니다.
> 
- 시스템은 역할과 책임을 수행하는 객체로 분할되고 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다.
- 적절한 객체에게 적절한 책임을 할당해야 한다.

## 협력 속에 사는 객체

1. 객체는 충분히 협력적이어야 한다. 
2. 객체는 충분히 자율적이어야 한다. 

객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재다. 

### 상태와 행동을 함께 지닌 자율적인 객체

객체는 상태(state)와 행동(behavior)을 하나의 단위로 묶는 자율적인 존재다. 

객체는 다른 객체가 무엇(What)을 수행하는지는 알 수 있지만 어떻게(How) 수행하는지에 대해서는 알 수 없다. 

객체는 행동을 위해 필요한 상태를 포함하는 동시에 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다. 

### 협력과 메시지

- 객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로 부터 메시지를 수신한다.
- 협력은 메시지를 전송하는 객체와 메시지를 수신하는 객체 사이의 관계로 구성된다.
- 메시지를 전송하는 객체를 송신자(sender) 라고 부르고 메시지를 수신하는 객체를 수신자(receiver) 라고 부른다.

### 메서드와 자율성

- 객체가 수신된 메시지를 처리하는 방법을 메서드(method) 라고 한다.
- 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하여 객체의 자율성을 높인다.

## 객체지향의 본질

- 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.

# 2장. 이상한 나라의 객체

객체란 무엇인가 - 객체가 상태와 행동, 식별자를 가진 존재

## 객체, 그리고 이상한 나라

### 앨리스 객체

- 앨리스는 상태를 가지며 상태는 변경 가능하다.
- 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
    - 행동의 순서가 결과에 영향을 미친다.
- 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다.

## 객체, 그리고 소프트웨어 나라

하나의 개별적인 실체로 식별 가능한 물리적인 또는 개념적인 사물은 어떤 것이라도 객체가 될 수 있다. 

객체는 상태(state), 행동(behavior), 식별자(identity)를 지닌 실체이다. 

### 상태

> 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값(속성)과 다른 객체를 참조하는 링크로 구분할 수 있다.
> 
- 객체의 상태를 구성하는 모든 특징을 객체의 프로퍼티(property)라고 한다.
- 프로퍼티는 변경되지 않고 고정되기 때문에 정적인 반면 프로퍼티 값은 시간이 흐름에 따라 변경되기 때문에 동적이다.
- 객체와 객체 사이의 의미 있는 연결을 링크라고 한다. 객체와 객체 사이에는 링크가 존재해야만 요청을 보내고 받을 수 있다. (= 메시지를 주고 받을 수 있다.)

### 행동

> 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
> 

**상태와 행동**

- 객체의 상태를 변경하는 것은 객체의 자발적인 행동 뿐이다.
- 객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.
- 상태와 행동 사이의 관계
    - 객체의 행동은 상태에 영향을 받는다
    - 객체의 행동은 상태를 변경시킨다.

**협력과 행동**

- 객체는 수신된 메시지에 따라 적절히 행동하면서 협력에 참여하고 그 결과로 자신의 상태를 변경한다.
- 객체의 행동으로 발생하는 부수효과
    - 객체 자신의 상태 변경
    - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송

**상태 캡슐화**

- 객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.
- 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 스스로 결정한다.
- 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.

### 식별자

> 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사(equality)를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 대문에 식별자를 이용한 동일성 검사(identical)를 통해 두 인스턴스를 비교할 수 있다.
> 
- 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티(=식별자)가 객체 안에 존재한다는 것을 의미한다.
- 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.

| 구분 | 객체 | 값 |
| --- | --- | --- |
| 상태의 변경 | 가변 상태(mutable state) | 불변 상태(immutable state) |
| 비교의 기준 | 식별자 비교 | 상태 비교 |
- **참조 객체(reference object), 엔티티(entity)** - 식별자를 지닌 전통적인 의미의 객체
- **값 객체(value object)** - 식별자를 가지지 않는 값을 가리키는 용어
- 객체의 특성
    1. 객체는 상태를 가지며 상태는 변경 가능하다.
    2. 객체의 상태를 변경시키는 것은 객체의 행동이다.
        1. 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다. 
        2. 행동의 순서가 실행 결과에 영향을 미친다.
    3. 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다. 
    

## 기계로서의 객체

일반적으로 객체의 상태를 조회하는 작업을 쿼리(query)라고 하고 객체의 상태를 변경하는 작업을 명령(command)라고 한다. 

- 기계 = 객체
- 기계의 버튼 = 객체의 상태를 조회하거나 변경시키는 인터페이스
- 기계의 버튼을 눌러 상태를 변경하거나 상태 조회를 요청하는 것 = 객체의 행동을 유발하기 위해 메시지를 전송하는 것

## 행동이 상태를 결정한다

- 상태를 먼저 결정하고 행동을 나중에 결정하는 방법 = 나쁜 설계 방법
    1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 
    2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 
    3. 객체의 재사용성이 저하된다. 

<aside>
💡 협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다. (책임-주도 설계 Responsibility-Driven Design)

</aside>

## 은유와 객체

- 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 **의인화(anthropomorphism)** 이라고 한다.

# 3장. 타입과 추상화

추상화 - 동적인 객체들을 단순화시켜 정적인 타입으로 갈무리하는 것

## 추상화를 통한 복잡성 극복

> 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
> 
- 추상화의 두 차원
    1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
    2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.  

## 객체지향과 추상화

> 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
> 
- 공통점을 기반으로 객체들을 묶기 위한 그릇을 개념(concept)이라고 한다.
- 개념을 이용하면 객체를 여러 그룹으로 분류(classification)할 수 있다.
- 개념 그룹의 일원이 될 때 객체를 그 개념의 인스턴스(instance)라고 한다.

### 개념의 세 가지 관점

- 심볼(symbol) - 개념을 가리키는 간략한 이름이나 명칭
- 내연(intension) - 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
- 외연(extension) - 개념에 속하는 모든 객체의 집합(set)

### 객체를 분류하기 위한 틀

> 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심 했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.
> 

### 분류는 추상화를 위한 도구다

> 개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 차원을 모두 사용한다.
> 
- 개념은 추상화의 첫번째 차원인 일반화를 적용한 결과다.
- 추상화의 두번째 차원에 따라 불필요한 세부사항을 제거한다.

## 타입

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타이을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
> 

### 데이터 타입

> 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.
> 
1. 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 

### 객체와 타입

1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 

### 행동이 우선이다

- 동일한 책임(=행동=메시지 수신)을 수행하는 일련의 객체는 동일한 타입에 속한다고 할 수 있다.
- 객체를 결정하는 것은 행동이다.

## 타입의 계층

객체가 동일한 타입으로 분류되기 위해서는 공통의 행동을 가져야만 한다. 

### 일반화/특수화 관계

- 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다.
- 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지고 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가진다. 단, 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 한다.

### 슈퍼타입과 서브타입

- 슈퍼타입(Supertype) - 더 일반적인 타입
- 서브타입(Subtype) - 더 특수한 타입

## 정적 모델

### 타입의 목적

- 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.

### 결국 타입은 추상화다

- 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다.

### 동적 모델과 정적 모델

- 스냅샷(snapshot) - 객체가 특정 시점에 구체적으로 어떤 상태를 가지는지 표현한 것
- 동적 모델(dynamic model) - 스냅샷과 같이 실제 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착한 것
- 정적 모델(static model) - 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것

### 클래스

- 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. (구현 메커니즘)
- 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스이다.

# 4장. 역할, 책임, 협력

객체들은 협력에 참여하기 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행

개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라.

## 협력

### 요청하고 응답하며 협력하는 사람들

- 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.
- 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

## 책임

- 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다.

### 책임의 분류

- 객체의 책임은 “객체가 무엇을 알고 있는가(knowing)"와 “무엇을 할 수 있는가(doing)"로 구성된다.

| 아는 것(knowing) | 하는 것(doing) |
| --- | --- |
| 개인적인 정보에 관해 아는 것  | 객체를 생성하거나 계산을 하는 등의 스스로 하는 것 |
| 관련된 객체에 관해 아는 것  | 다른 객체의 행동을 시작시키는 것 |
| 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것  | 다른 객체의 활동을 제어하고 조절하는 것 |
- 책임은 객체의 공용 인터페이스(public interface)를 구성한다.

### 책임과 메시지

- 협력 안에서 객체는 다른 객체로부터 요청이 전송 됐을 경우에만 자신에게 주어진 책임을 수행한다.
- 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)라고 한다.
- 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.

## 역할

### 책임의 집합이 의미하는 것

- 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.
- 동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다.
- 역할은 객체지향 설계의 단순성(simplicity), 유연성(flexibility), 재사용성(reusability)을 뒷받침한다.

### 협력의 추상화

- 역할을 이용하여 협력을 추상화할 수 있다.

### 대체 가능성

- 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자이다.
- 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다.
- 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.

## 객체의 모양을 결정하는 협력

### 협력을 따라 흐르는 객체의 책임

- 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미한다. 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.
- 객체에게 책임을 할당하고 나면 책임은 객체가 외부에 제공하게 될 행동이 된다.

## 객체지향 설계 기법

역할, 책임, 협력의 관점에서 애플리케이션을 설계하는 유용한 세가지 기법

1. 책임-주도 설계(Responsibility-Driven Design)
    - 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.
2. 디자인 패턴(Design Pattern)
    - 전문가들이 특정 문제를 해결하기 위해 이미 식별해 높은 역할, 책임, 협력의 모음이다.
3. 테스트-주도 개발(Test-Driven Development)
    - 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식
    - 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적합한지를 피드백 받는 것이다.

### 책임-주도 설계

> 객체의 책임을 중심으로 시스템을 구축하는 설계 방법
> 
- 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다.
- 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축한다.
- 객체 지향 시스템을 설계하는 절차
    1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    2. 시스템 책임을 더 작은 책임으로 분할한다.
    3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 
    5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 

### 디자인 패턴

> 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다.
> 
- 디자인 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.

### 테스트-주도 개발

> 테스트-주도 개발의 기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후, 리팩토링을 통해 중복을 제거하는 것이다.
> 

# 5장. 책임과 메시지

훌륭한 메시지가 훌륭한 객체지향 설계의 기반

## 자율적인 책임

### 설계의 품질을 좌우하는 책임

> 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다
> 
- 책임 - 요청을 처리하기 위해 객체가 수행하는 행동
- 적절한 책임의 선택이 전체 설계의 방향을 결정한다.
- 협력에 참여하는 객체가 얼마나 자율적인지가 전체 애플리케이션의 품질을 결정한다.

### ‘어떻게'가 아니라 ‘무엇'을

- 자율적인 책임의 특징
    - 객체가 ‘어떻게' 해야 하는가가 아니라 ‘무엇'을 해야 하는가를 설명한다.

### 책임을 자극하는 메시지

- 객체가 자신에게 할당된 책임을 수행하도록 만드는 것은 외부에서 전달되는 요청(메시지)이다.

## 메시지와 메서드

### 메시지

- 메시지는 메시지 이름(message name)과 인자(argument)의 두 부분으로 구성된다.
- 메시지-전송은 수신자, 메시지 이름, 인자의 조합으로 구성된다.
- 외부의 객체는 메시지에 관해서만 볼 수 있고 객체 내부는 볼 수 없기 때문에 자연스럽게 객체의 외부와 내부가 분리된다.

### 메서드

> 메시지를 수신 했을 때 책임을 수행하는 방법
> 
- 객체지향 프로그래밍 언어에서 메서드는 클래스안에 포함된 함수 또는 프로시저를 통해 구현된다.

### 다형성

> 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘
> 
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.
- 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다.

### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

1. 협력이 유연해진다.
    
    파급효과 없이 유연하게 협력을 변경할 수 있다.
    
2. 협력이 수행되는 방식을 확장할 수 있다. 
3. 협력이 수행되는 방식을 재사용 할 수 있다. 

### 송신자와 수신자를 약하게 연결하는 메시지

- 메시지는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만든다.

## 메시지를 따라라

### 객체지향의 핵심, 메시지

- 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.
- 시스템의 기능을 구현하기 위해 객체가 다른 객체에게 제공해야 하는 메시지에 대해 고민해라.

### 책임-주도 설계 다시 살펴보기

- 책임을 완수하기 위해 협력하는 객체들을 이용해 시스템을 설계하는 방법
- 객체들 간에 주고받는 메시지를 기반으로 적절한 역할과 책임, 협력을 발견하는 것이다.
- 애플리케이션이 수행하는 기능 = 시스템의 책임
- 시스템의 책임을 객체의 책임으로 할당 - 책임을 완수하기 위해 필요한 도움을 요청하기 위해 어떤 메시지가 필요한지 결정 - 메시지를 수신하기에 적합한 객체를 선택

### What/Who 사이클

> 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 과정
> 
1. 어떤 행위(what)을 결정
2. 누가(who) 그 행위를 수행할 것인지 결정

### 묻지 말고 시켜라(Tell, Don’t Ask, 데메테르 법칙)

> 객체는 다른 객체의 결정에 간섭하지 말아야 하며, 모든 객체는 자신의 상태를 기반으로 스스로 결정을 내려야 한다.
> 
- 객체는 다른 객체의 상태를 묻지 말아야 한다.
- 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게 만든다.

### 메시지를 믿어라

- 중요한 것은 메시지를 수신하는 객체가 메시지의 의미를 이해하고 메시지를 전송한 객체가 의도한 대로 요청을 처리할 수 있는지 여부다.

## 객체 인터페이스

### 인터페이스

> 객체가 다른 객체와 협력하기 위한 접점
> 
- 인터페이스 특징
    1. 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
    2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
    3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있다. 

### 메시지가 인터페이스를 결정한다

- 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스를 만든다.

### 공용 인터페이스

> 외부에 공개된 인터페이스
> 
- 공용이건 사적이건 상관없이 모든 인터페이스는 메시지 전송을 통해서만 접근할 수 있다.
- 공용 인터페이스를 자극해서 책임을 수행하게 하는 것은 객체에게 전송되는 메시지다.
- 객체의 공용 인터페이스를 구성하는 것은 객체가 외부로부터 수신할 수 있는 메시지의 목록이다.

## 인터페이스와 구현의 분리

### 객체 관점에서 생각하는 방법

1. 좀 더 추상적인 인터페이스
2. 최소 인터페이스
    
    외부에섯 사용할 필요가 없는 인터페이스는 최대한 노출하지 말라는 것
    
3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

### 구현

> 내부 구조와 작동 방식
> 
- 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.
- 객체의 외부와 내부를 분리 = 객체의 공용 인터페이스와 구현을 명확하게 분리

### 인터페이스와 구현의 분리 원칙

- 변경을 관리하기 위한 것

### 캡슐화(정보 은닉)

> 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것
> 
- 관점
    1. 상태와 행위의 캡슐화 = 데이터 캡슐화
        - 객체는 상태와 행위의 조합으로 스스로 자신의 상태를 관리하며 상태를 변경하고 외부에 응답할 수 있는 행동을 내부에 함께 보관한다.
        - 객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 하는 행위만 골라 공오ㅛㅇ 인터페이스를 통해 노출한다.
    2. 사적인 비밀의 캡슐화
        - 변경이 빈번하게 일어나는 불안정한 비밀을 안정적인 인터페이스 뒤로 숨길 수 있다.
        - 불안정한 비밀은 구현과 관련된 세부 사항을 의미한다.

## 책임의 자율성이 협력의 품질을 결정한다

- 객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 된다.
1. 자율적인 책임은 협력을 단순하게 만든다.
2. 자율적인 책임은 객체의 외부와 내부를 명확하게 분리한다. 
3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다. 
    
    변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다.
    
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다. 
5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다. 

# 6장. 객체 지도

객체지향이 구조와 기능이라는 두 가지 관점을 어떻게 조화시키는지

## 기능 설계 대 구조 설계

1. 기능 측면의 설계 - 제품이 사용자를 위해 무엇을 할 수 있는지에 초점
2. 구조 측면의 설계 - 제품의 형태가 어떠해야 하는지에 초점
- 객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만든다. 시스템 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기 때문에 기능이 변겨되더라도 객체 간의 구조는 그대로 유지된다.

## 두 가지 재료: 기능과 구조

- 사용자에게 제공할 기능
    - 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.
- 기능을 담을 안정적인 구조
    - 기능 변경을 수용할 수 있도록 안정적이어야 한다.
    - 사용자나 이해관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
- 유스케이스 모델링 - 기능을 수집하고 표현하기 위한 기법
- 도메인 모델링 - 구조를 수집하고 표현하기 위한 기법

## 안정적인 재료: 구조

### 도메인 모델

> 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.
> 
- 사용자가 프로그램을 사용하는 대상 분야를 도메인이라 한다.
- 도메인 모델은 이해관계자들이 바라보는 멘탈 모델이다.
- 도메인 모델은 도메인에 대한 사용자 모델(사용자가 제품에 대해 가지고 있는 개념들의 모습), 디자인 모델(설계자가 마음 속에 갖고 있는 시스템에 대한 개념화), 시스템 이미지(최종 제품)를 포괄하도록 추상화한 소프트웨어 모델이다.

### 도메인의 모습을 담을 수 있는 객체지향

> **연결완전성 또는 표현적 차이?** 객체지향을 이용했을 때 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 특성
> 

### 표현적 차이

> 소프트웨어 객체와 현실 객체 사이의 의미적 거리
> 
- 도메인 모델을 기반으로 설계하고 구현하는 것은 표현적 차이를 줄어들게 할 것이며 사용자의 멘탈 모델이 그대로 코드에 스며들게 한다.

### 불안정한 기능을 담는 안정적인 도메인 모델

- 사용자 모델에 포함된 개념과 규칙은 비교적 변경될 확률이 적기 때문에 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있을 가능성이 커진다.
- 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다.

## 불안정한 재료: 기능

### 유스케이스

> 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것
> 
- 기능적 요구사항 - 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것
- 유스케이스의 특성
    1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 텍스트다.
    2. 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다. 
        
        시나리오(=유스케이스 인스턴스)는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다. 
        
    3. 유스케잇스는 단순한 피처(feature)목록과 다르다. 
        
        피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것
        
    4. 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다. (본질적인 유스케이스-essential use case)
    5. 유스케이스는 내부 섯ㄹ계와 관련된 정보를 포함하지 않는다. 

### 유스케이스는 설계 기법도, 객체지향 기법도 아니다

- 유스케이스는 시스템의 내부 구조나 실행 메커니즘에 관한 어떤 정보도 제공하지 않는다. 유스케이스에는 단지 사용자가 시스템을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있느냐에 관한 정보만 기술된다.
- 유스케이스는 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않는다.

## 재료 합치기: 기능과 구조의 통합

### 도메인 모델, 유스케이스, 그리고 책임-주도 설계

- 유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다.
- 도메인 모델은 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다.
- 책임-주도 설계는 유스케이스로부터 첫 번째 메시지와 사용자가 달성하려는 목표를, 도메인 모델로부터 기능을 수용할 수 있는 안정적인 구조를 제공받아 싯ㄹ제로 동작하는 객체들의 협력 공동체를 찾오한다.
- 책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력관계로 바라보게 함으로써 두 가지 기본 재료인 유스케이스와 도메인 모델을 통합한다.

### 기능 변경을 흡수하는 안정적인 구조

- 도메인 모델을 기반으로 객체 구조를 설계하는 이유는 도메인 모델이 안정적이기 때문이다.
    - 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다.
    - 도메인 모델을 구성하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다.
- 객체지향에서는 도메인 모델과 코드 모두 동일한 모델링 패러다임을 공유하기 때문에 코드의 수정이 곧 모델의 수정이 된다.
- 모델에서 코드로의 매끄러운 흐름을 의미하는 연결완전성과 반대로 코드에서 모델로의 매끄러운 흐름을 의미하는 것을 가역성이라고 한다.

# 7장. 함께 모으기

객체지향 설계 안에 존재하는 세가지 상호 연관된 관점이 있다. 

- 개념 관점(Conceptual Perspective)
    - 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현
    - 사용자가 도메인을 바라보는 관점을 반영한다.
- 명세 관점(Specification Perspective)
    - 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 즉, 객체의 인터페이스를 바라보게 된다.
    - 객체가 협력을 위해 ‘무엇'을 할 수 있는가에 초점을 맞춘다.
- 구현 관점(Implementation Perspective)
    - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.
    - 객체의 책임을 ‘어떻게’ 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.
    

## 커피 전문점 도메인

### 커피 전문점이라는 세상

- 커피 전문점은 객체들로 구성된 작은 세상
- 객체 - 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체
- 타입
    - 손님 객체는 ‘손님 타입’의 인스턴스
    - 바리스타 객체는 ‘바리스타 타입'의 인스턴스
    - 아메리카노 커피, 에스프레소 커피, 카라멜 마키아또 커피, 카푸치노 커피는 모두 ‘커피 타입'의 인스턴스
    - 메뉴판 객체는 아메리카노, 에스프레소, 카라멜 마키아또, 카푸치노라는 네 개의 메뉴 항목 객체를 포함한다. 각 메뉴 항목은 ‘메뉴 항목 타입'의 인스턴스
- 관계
    - 메뉴 항목이 메뉴판에 포함된다. (합성 관계 - composition)
    - 손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 선택할 수 있다. (연관 관계 - association)

## 설계하고 구현하기

### 커피를 주문하기 위한 협력 찾기

메시지를 처리할 객체를 찾는다면 먼저 도메인 모델 안에 책임을 수행하기에 적절한 타입이 존재하는지를 봐야 한다. 

적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들어라. 

- 스스로 할 수 없는 일은 메시지를 전송해 다른 객체에게 도움을 요청한다.

### 인터페이스 정리하기

- 메시지가 객체를 선택하고 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.
- 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 멧시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.
- 협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부이다. 따라서 인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 공용(`public`)으로 선언되어 있어야 한다.

### 구현하기

- 클래스의 인터페이스를 식별했으면 이제 오퍼레이션을 수행하는 방법을 메서드로 구현한다.

## 코드와 세 가지 관점

### 코드는 세 가지 관점을 모두 제공해야 한다.

- 개념 관점은 클래스를 바라본다.
- 명세 관점은 클래스의 인터페이스를 바라본다.
- 구현 관점은 클래스의 내부 구현을 바라본다.
    - 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.

### 도메인 개념을 참조하는 이유

- 어떤 메시지가 있을 때 그 메시지를 수신할 객체를 선택하는 방법 → 도메인 개념 중에서 가장 적절한 것을 선택
- 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

### 인터페이스와 구현을 분리하라

- 캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안 되고, 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어 놓아서도 안된다.